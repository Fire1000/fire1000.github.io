<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>《Primer C++, 5th Edition》Stanley B. Lippman 第2章 变量和基本类型 笔记 | Fly_Fire1000的博客</title>
<link rel="shortcut icon" href="https://fire1000.github.io/favicon.ico?v=1654603203619">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fire1000.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="《Primer C++, 5th Edition》Stanley B. Lippman 第2章 变量和基本类型 笔记 | Fly_Fire1000的博客 - Atom Feed" href="https://fire1000.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="类型
C++是静态类型语言，类型检查发生在编译时。
内置类型分为算术类型和空类型(void)，算术类型分为整型(含字符、布尔)和浮点。

short &lt;= int &lt;= long &lt;= long long，longlong..." />
    <meta name="keywords" content="Primer C++" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://fire1000.github.io">
  <img class="avatar" src="https://fire1000.github.io/images/avatar.png?v=1654603203619" alt="">
  </a>
  <h1 class="site-title">
    Fly_Fire1000的博客
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              《Primer C++, 5th Edition》Stanley B. Lippman 第2章 变量和基本类型 笔记
            </h2>
            <div class="post-info">
              <span>
                2022-02-11
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://fire1000.github.io/tag/o9RLdT_jv/" class="post-tag">
                  # Primer C++
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="类型">类型</h2>
<p>C++是静态类型语言，类型检查发生在编译时。</p>
<p>内置类型分为算术类型和空类型(void)，算术类型分为整型(含字符、布尔)和浮点。<br>
<img src="https://fire1000.github.io/post-images/1644585161805.png" alt="" loading="lazy"><br>
short &lt;= int &lt;= long &lt;= long long，longlong是C++11中定义的。<br>
通常float 32 bit，7位有效数字，double 64bit，16位有效数字。long double 96或128 bit，有效数字取决于具体实现。<br>
unsigned int缩写为unsigned。<br>
字符类型有三种：char、signed char和unsigned char。char有无符号取决于编译器。<br>
C++标准约定有符号类型的正值与负值范围应该平衡。因此8 bit signed char通常为-128至127。</p>
<p>算术类型选择建议：</p>
<ol>
<li>数值超过int时，选long long，因long通常与int一样大。</li>
<li>浮点选double，因double与float运算性能无差，一些机器double更快。long double的性能消耗不容忽视。</li>
</ol>
<p>将超过范围的数，赋值有符号类型，结果是未定义。</p>
<h2 id="类型转换">类型转换</h2>
<p>类型转换：</p>
<ol>
<li>
<p>非布尔转布尔，0为false，非0为true。</p>
</li>
<li>
<p>布尔转非布尔，false为0，true为1。</p>
</li>
<li>
<p>整数转浮点，如果整数占的空间超过浮点，精度有损失。</p>
</li>
<li>
<p>将布尔用在算术表达式中时，转为非布尔。</p>
</li>
<li>
<p>整数算术运算时：</p>
<ol>
<li>转换成占用空间较大的类型。</li>
<li>当占用空间相同时，如果存在无符号类型，转为无符号类型。</li>
</ol>
</li>
</ol>
<h2 id="字面值">字面值</h2>
<p>无后辍的的字面值：</p>
<ol>
<li>十进制的是有符号的，类型是int、long、long long中能容纳它的占用空间最小的那个。</li>
<li>八进制和十六进制的可以是有符号，或无符号的。类型是int、long、long long与对应的无符号版本中能容纳它的占用空间最小的那个，占用空间相同的类型优先有符号的。</li>
<li>浮点是double。</li>
</ol>
<ul>
<li>超过能容纳它的最大类型的字面值，会报错。</li>
<li>严格说数字字面值不会为负，因负号是运算符。</li>
</ul>
<p>转义序列以反斜杠开头。</p>
<ol>
<li>后跟最多3个八进制，如<code>\40</code>(空格)，<code>\1234</code>表示<code>\123</code>和<code>4</code>。</li>
<li>后跟任意个十六进制，如<code>\x4d</code>(字符M)。但大小超过对应字符类型范围会报错。</li>
</ol>
<ul>
<li>数字转义序列表示的字符，取决于字符集。</li>
</ul>
<p>字面值前后辍表：<br>
<img src="https://fire1000.github.io/post-images/1644636629027.png" alt="" loading="lazy"><br>
字符前辍l也表示宽字符，但是与数字1容易混淆，只建议使用L。</p>
<p>nullptr是指针字面值。</p>
<h2 id="初始化">初始化</h2>
<p><code>double price = 109.99, discount = price * 0.16;</code>是合法的。</p>
<p>C++11新增了列表初始化。如果初始化时发生的类型转换，会丢失信息，则报错：</p>
<pre><code>long double ld = 3.14;
int a{ld}, b = {ld}; // 列表初始化，因为ld丢失信息，报错。
int c(ld), d = ld; // 正确。
</code></pre>
<p>如果声明时不显式初始化：</p>
<ol>
<li>内置类型的静态变量，隐式初始化为0。</li>
<li>内置类型的自动变量不被初始化，值是未定义的。</li>
<li>类是否被隐式初始化是自定义的。<code>std::string empty;</code>将empty隐式初始化为空串。</li>
</ol>
<h2 id="声明定义">声明&amp;定义</h2>
<p>C++支持分离式编译：程序分割成多个文件，独立编译。</p>
<p>包含显式初始化的声明是定义，不论是否extern。</p>
<ul>
<li>内部变量的声明，同时带显式初始化和extern将报错。<br>
不包含显式初始化的声明：</li>
</ul>
<ol>
<li>带extern只是声明。</li>
<li>不带extern是定义。</li>
</ol>
<p>建议当第一次使用变量时再定义它。</p>
<h2 id="名字">名字</h2>
<p>C++为标准备保留的名称：</p>
<ol>
<li>连续两个下划线开头。</li>
<li>下划线后跟大写字母开头。</li>
<li>函数外，下划线开头。</li>
</ol>
<p>约定俗成的命名规范：</p>
<ol>
<li>变量名小写。</li>
<li>自定义的类名大写。</li>
<li>多单词的名称，单词之间应有区分，如下划线或驼峰。</li>
</ol>
<p>C++关键字：<img src="https://fire1000.github.io/post-images/1644641140774.png" alt="" loading="lazy"></p>
<p>操作符替代名可以替代操作符，如<code>a &amp;&amp; b</code>等价于<code>a and b</code>。<br>
gcc可以直接使用，部分编译器要包含&lt;iso646.h&gt;才能使用。<br>
<img src="https://fire1000.github.io/post-images/1644641247930.png" alt="" loading="lazy"></p>
<p>作用域通常以{}分隔。<br>
外部变量有全局作用域。</p>
<p>内层作用域允许定义外层作用域已有的名字，但这种做法不推荐。直接通过名字访问时，访问的是内层作用域的名字。通过::运算符可以访问外层作用域的名字，如<code>::reused</code>访问全局作用域的reused变量。</p>
<h2 id="指针和引用">指针和引用</h2>
<p>指针是对象，提供对对象的间接访问。<br>
void *指针可以存放任意类型的指针，如<code>double obj = 3.14; void *pv = &amp;obj</code>。</p>
<p>空指针：</p>
<ol>
<li>在C中<code>int *p = (void *)0;</code>是正确的，因为void *是通用指针，但C++是错误的，因为void *与int *类型不同。</li>
<li>在C中<code>int *p = 1;</code>是正确的，但C++中也是错误的，因为int *与int类型不同。</li>
<li>但在C++中，<code>int *p = 0;</code>是正确的，这是特殊处理的结果。</li>
<li>NULL在C中定义为<code>((void *)0)</code>，而在C++中定义如下：</li>
</ol>
<pre><code>#ifndef __cplusplus
#define NULL ((void *)0)
#else
#define NULL 0
</code></pre>
<p>因此C++11定义了指针字面值nullptr(值为0)，替代NULL和0作为空指针。</p>
<p>C++11新增了右值引用，但「引用」通常特指左值引用。<br>
「引用不是对象，只是别名。」存在误导，应为「引用使用时可以视为别名」，「引用不分配内存」则是完全错误。<br>
引用底层的实现方式与指针类似。定义引用时，也分配一段内存用于保存引用绑定的对象的地址，之后对引用的操作都通过间接访问这个地址来完成。<br>
从底层实现来看，引用大多数情况下都可以视为自带间接访问运算符的const指针。<br>
例外，当引用为作形参时，数组不会退化为指针。</p>
<p>作为自动变量的引用声明时必须显示初始化，静态变量则不需要。因为创建引用需要一个地址。</p>
<pre><code>int &amp;i; // 正确
main()
{
    int a;
    int &amp;j; // 错误
    int &amp;k = a; // 正确
}
</code></pre>
<p>允许声明指针的引用：</p>
<pre><code>int i = 42;
int *p;
int *&amp;r = p;
r = &amp;i;
*r = 0; // i = 0
</code></pre>
<h2 id="const">const</h2>
<p>const变量，如果可能的话，会在编译期被替换为它的值(宏是预编译期)，如<code>const int bufSize = 512;</code>。因此const变量，默认作用域仅在当前文件。<br>
当const的声明与定义都使用extern时，作用域为全局，所有文件声明的const变量都是同一个。显然此时，编译期无法替换它的值。</p>
<p>指向const变量的指针，指向的类型必须声明为const，称为指向const的指针(与const指针区分)。如<code>const double pi = 3.14; const double *cptr = &amp;pi;</code>。<br>
指向const的指针的含义仅仅是不允许通过指向const的指针修改变量的值。因此：</p>
<ol>
<li>指向const的指针本身的值，是可以改变的。</li>
<li>指向const的指针，可以指向非const变量。</li>
</ol>
<pre><code>const double pi = 3.14; 
const double *cptr = &amp;pi;
double dval = 2;
cptr = &amp;dval;
</code></pre>
<p>const指针本身是不能被修改，仅能在声明时设定初值。如：<code>int errNumb = 0; int *const curErr = &amp;errNumb;</code>。<br>
可以通过const指针修改指向的变量的值。如<code>*curErr = 0;</code>。<br>
指向const的指针，可以同时是const指针，如<code>const double pi = 3.14; const double *const pip = &amp;pi;</code></p>
<p>注意：指向字符串字面值的指针，不需要为指向const的指针，虽然修改会导致错误。</p>
<p>与指针相同，引用理论上也分为指向const的本身const的。但因为引用保存的地址本身就无法修改，没有使用的价值，通常把指向const的引用，称为const引用。<br>
与指向const的指针相同</p>
<ol>
<li>const变量的引用，必须声明为const引用：<pre><code>const int ci = 1024;
int &amp;r2 = ci; // 错误
</code></pre>
</li>
<li>允许声明非const变量的const引用：<code>int i = 42; const int &amp;r1 = i;</code></li>
</ol>
<p>与指针不同的是，允许声明字面值的const引用，如<code>const int &amp;r = 42;</code></p>
<h2 id="常量表达式">常量表达式</h2>
<p>常量表达式指值不会改变，编译过程中就能得到结果的表达式，字面值是常量表达式。<br>
非const变量一定不是常量表达式，const变量不一定是常量表达式。</p>
<pre><code>const  int max_files = 20; // 是
const int limit = max_files + 1; // 是
int staff_size = 27; // 不是
const int sz = get_size(); //  不是
</code></pre>
<p>constexpr是C++11新增关键字，constexp用于声明常量表达式，如果它的值不是常量表达式，则编译器报错。</p>
<pre><code>constexpr  int mf = 20; // 正确
constexpr int limit = mf + 1; // 正确
constexpr in sz = size(); // 当size是constexpr函数时正确，否则错误。
</code></pre>
<p>与const同样，constexpr变量也不允许修改。</p>
<pre><code>constexpr int a = 1;
a = 2; // 错误
</code></pre>
<p>允许使用constexpr声明指针。必须注意的是，constexpr只能写在*左边，但含义却是指针本身是常量表达式，能在编译期确定地址的只有静态变量和字面值。</p>
<pre><code>// i和j写在函数外，与k一样是静态变量
constexpr int i = 42; // 作为指针指向的对象时，类型作视为const int
int j = 0;

main()
{
    constexpr int *np = nullptr; // 正确

    constexpr int *pi1 = &amp;i; // 错误 int *const不能指向const int
    constexpr const int *pi2 = &amp;i;   // 正确
    const int *pi3 = &amp;i;  // 正确
    constexpr const int *const pi4 = &amp;i;  // 正确 但constexpr功能上已包含了*const

    constexpr int *pj = &amp;j;  // 正确
    *pj = 5; // 正确，允许通过constexpr指针，修改指向对象的值。

    static int k = 1;  // 正确
    static constexpr int *pk = &amp;k;  // 正确

    constexpr char *ps = &quot;123&quot;; // 正确
}
</code></pre>
<p>允许使用constexpr声明引用，与指针类似，constexpr引用指的是引用保存的地址是常量表达式，因引用的地址本就不能修改，只需要地址是常量表达式即可。</p>
<pre><code>constexpr int &amp;a1; // 正确
constexpr const int &amp;a2 = 123;  // 正确

int n;

main()
{
    constexpr int &amp;b1 = n;  // 正确
    constexpr const int &amp;b2 = n; // 正确

    constexpr const int &amp;c = 321; // 错误。推测，函数内非字符串字面值的内存是运行期分配
}
</code></pre>
<p>p60 类型处理</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B">类型</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E5%80%BC">字面值</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%9A%E4%B9%89">声明&amp;定义</a></li>
<li><a href="#%E5%90%8D%E5%AD%97">名字</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">指针和引用</a></li>
<li><a href="#const">const</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">常量表达式</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://fire1000.github.io/post/lesslessprimer-c-5th-editiongreatergreater-stanley-b-lippman-di-1-zhang-kai-shi-bi-ji/">
              <h3 class="post-title">
                《Primer C++, 5th Edition》Stanley B. Lippman 第1章 开始 笔记
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '660966b39935a77f9dcd',
    clientSecret: '7c7b060856a916461e6a5d6e9c2141d9a2d2a045',
    repo: 'fire1000.github.io',
    owner: 'Fire1000',
    admin: ['Fire1000'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://fire1000.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
