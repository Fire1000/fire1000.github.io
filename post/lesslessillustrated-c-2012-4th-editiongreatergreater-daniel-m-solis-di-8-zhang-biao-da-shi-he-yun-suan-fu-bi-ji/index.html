<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第8章 表达式和运算符 笔记 | Fly_Fire1000的博客</title>
<link rel="shortcut icon" href="https://fire1000.github.io/favicon.ico?v=1663500262300">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fire1000.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第8章 表达式和运算符 笔记 | Fly_Fire1000的博客 - Atom Feed" href="https://fire1000.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="表达式
表达式除了返回一个值以外的功能，称为副作用，比如分配内存，又比如赋值表达式设置左边操作数的值是它的副作用。
字面值
整数字面值后辍：

整数字面值的类型是，后辍对应的类型中，能容纳这个值的最小的类型。
浮点数字面值后辍：

字符字面..." />
    <meta name="keywords" content="Illustrated C# 2012" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://fire1000.github.io">
  <img class="avatar" src="https://fire1000.github.io/images/avatar.png?v=1663500262300" alt="">
  </a>
  <h1 class="site-title">
    Fly_Fire1000的博客
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第8章 表达式和运算符 笔记
            </h2>
            <div class="post-info">
              <span>
                2022-06-18
              </span>
              <span>
                3 min read
              </span>
              
                <a href="https://fire1000.github.io/tag/xtgDb0zlW/" class="post-tag">
                  # Illustrated C# 2012
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="表达式">表达式</h2>
<p>表达式除了返回一个值以外的功能，称为副作用，比如分配内存，又比如赋值表达式设置左边操作数的值是它的副作用。</p>
<h2 id="字面值">字面值</h2>
<p>整数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655523693428.png" alt="" loading="lazy"><br>
整数字面值的类型是，后辍对应的类型中，能容纳这个值的最小的类型。</p>
<p>浮点数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655633313375.png" alt="" loading="lazy"></p>
<p>字符字面值有四种：<br>
<img src="https://fire1000.github.io/post-images/1655634956854.png" alt="" loading="lazy"><br>
\x和\u都后跟4位十六进制数。</p>
<ul>
<li>经测试\x和\u完全没有区别，编码为UCS-2 BE。'\x4E2D'和'\u4E2D'都输出<code>中</code>，测试环境为Intel CPU。</li>
</ul>
<p>转义序列：<br>
<img src="https://fire1000.github.io/post-images/1655635304774.png" alt="" loading="lazy"></p>
<p>@前辍的字符串是逐字字符串：</p>
<ol>
<li>转义序列不被求值。</li>
<li>支持换行符。</li>
<li>连续的两个引号解释为一个引号。</li>
</ol>
<p>除了rst3和vst3，以下逐字字符串与普通字符串有完全相同的输出：<br>
<img src="https://fire1000.github.io/post-images/1655710704418.png" alt="" loading="lazy"></p>
<p>C#编译器使得相同的字符串字面值占堆中同一块内存。</p>
<h2 id="运算符">运算符</h2>
<p>运算符优先级：<br>
<img src="https://fire1000.github.io/post-images/1655710924275.png" alt="" loading="lazy"></p>
<p>运算符结合性：<br>
<img src="https://fire1000.github.io/post-images/1655710956571.png" alt="" loading="lazy"></p>
<p>C#求余运算符%支持浮点数。</p>
<p>与C/C++不同，C#中数字不具有布尔意义。<br>
相等运算符比较引用类型时，除了比较string和委托使用深比较，其他都使用浅比较。</p>
<ul>
<li>浅比较只比较引用的地址。</li>
<li>深比较只比较引用指向的内存中的数据。</li>
</ul>
<p>C#中&amp;&amp;和||是短路运算符，当左边的表达式足以确定返回值时，右边的表达式不求值。</p>
<p>C#中右移运算符，对于有符号整数符号位填充，对于无符号整数0填充。</p>
<p>if...else语句执行两个行为其中一个，条件运算符返回两个值其中一个。</p>
<h2 id="自定义类型转换">自定义类型转换</h2>
<p>C#支持自定义类型转换，隐式转换由编译器依据上下文自行调用，显式转换在使用强制转换运算符时调用。<br>
自定义类型转换的语法：<br>
<img src="https://fire1000.github.io/post-images/1655720026416.png" alt="" loading="lazy"></p>
<ul>
<li>显式转换使用explicit关键字，隐式转换使用implicit关键字。</li>
<li>无论是显式转换还是隐式转换，public和static修饰符都是必需的。</li>
<li>源类型与目标类型不能相同。</li>
</ul>
<h2 id="运算符重载">运算符重载</h2>
<p>运算符重载的参数至少要有一个是所属的类或结构类型，语法如下：<br>
<img src="https://fire1000.github.io/post-images/1655720993031.png" alt="" loading="lazy"></p>
<ul>
<li>public和static修饰符是必需的。</li>
</ul>
<p>可重载的运算符：<br>
<img src="https://fire1000.github.io/post-images/1655721044770.png" alt="" loading="lazy"></p>
<ul>
<li>强制转换计入自定义类型转换，不计入运算符重载。</li>
</ul>
<h2 id="typeof运算符">typeof运算符</h2>
<p>typeof运算符与实例的GetType()方法相同，返回System.Type对象，直接打印这个对象会输出类型名。通过GetFields()和GetMethods()方法，还可以获得字段成员和方法成员信息：<br>
<img src="https://fire1000.github.io/post-images/1655722585884.png" alt="" loading="lazy"></p>
<ul>
<li>FieldInfo和MethodInfo在System.Reflection命名空间中定义。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fire1000.github.io/post-images/1655722663460.png" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E5%80%BC">字面值</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自定义类型转换</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
<li><a href="#typeof%E8%BF%90%E7%AE%97%E7%AC%A6">typeof运算符</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-7-zhang-lei-he-ji-cheng-bi-ji/">
              <h3 class="post-title">
                《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第7章 类和继承 笔记
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '660966b39935a77f9dcd',
    clientSecret: '7c7b060856a916461e6a5d6e9c2141d9a2d2a045',
    repo: 'fire1000.github.io',
    owner: 'Fire1000',
    admin: ['Fire1000'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://fire1000.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
