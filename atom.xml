<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fire1000.github.io</id>
    <title>Fly_Fire1000的博客</title>
    <updated>2022-06-21T11:48:33.243Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fire1000.github.io"/>
    <link rel="self" href="https://fire1000.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://fire1000.github.io/images/avatar.png</logo>
    <icon>https://fire1000.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Fly_Fire1000的博客</rights>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第12章 数组 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/">
        </link>
        <updated>2022-06-21T10:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>数组的维度称作秩(rank)。<br>
C#有两种多维数组：矩形数组(rectangular array)和交错数组(jagged array)。</p>
<ul>
<li>矩形数组：<code>int x = mayArray2[4, 6, 1]</code></li>
<li>交错数组：<code>jagArray1[2][7][4]</code></li>
</ul>
<p>数组继承自System.Array。System.Array提供了很多属性和方法：<br>
<img src="https://fire1000.github.io/post-images/1655811997129.png" alt="" loading="lazy"></p>
<p>数组声明时，只确定数组的维度。<br>
维度长度不是数组类型的一部分，维度长度在数组实例化时才确定。<br>
与C/C++不同，方括号写在类型后，而不是变量名后。</p>
<p>数组实例化时同样使用new关键字，但不使用圆括号。<br>
数组实例化，元素被初始为元素类型的默认值。<br>
数组支持使用初始化列表初始化，由编译器推断维度长度。</p>
<pre><code>int[] intArr = new int[] {10, 20, 30, 40}; // int[4]
int[, ] intArray2 = new int[, ] { {10, 1}, {20, 2}, {30, 3} };  // int[3, 2]
</code></pre>
<p>如果在声明时初始化数组，C#提供了快捷语法和隐式类型数组(由编译器推断元素类型)：<br>
<img src="https://fire1000.github.io/post-images/1655810851145.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655810955554.png" alt="" loading="lazy"></p>
<p>交错数组初始化时，只能确定顶层维度长度：</p>
<pre><code>int[][] jagArr = new int[3][];
</code></pre>
<p>在CIL中，一维数组特定的性能优化指令，因此使用一维数组的交错数组，有时性能比矩形数组性能更好。</p>
<p>foreach语句中，迭代变量是只读的，可以使用var关键字声明。<br>
foreach语句必须嵌套才能遍历交错数组。</p>
<p>数组的协变：当数组元素为引用类型时，如果某个对象存在从自身类型到数组元素类型的隐式或显式转换，支持将这个元素赋值给数组元素。<br>
<img src="https://fire1000.github.io/post-images/1655811934220.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第11章 枚举 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/">
        </link>
        <updated>2022-06-21T08:02:18.000Z</updated>
        <content type="html"><![CDATA[<p>枚举是值类型。<br>
枚举的成员是命名的整数常量。</p>
<p>枚举的成员的默认类型为int，可以声明为任意整数类型：</p>
<pre><code>enum TrafficLight : ulong
{
    ...
</code></pre>
<p>枚举还常用作标志位。<br>
枚举的HasFlag方法和&amp;运算符，都可以检测一个枚举是否包含某个标志位。</p>
<pre><code>bool useFancyNumbers = ops.HasFlag(CardDeckSetttings.FancyNumbers);
</code></pre>
<ul>
<li>其中CardDeckSetttings是枚举类型，ops是CardDeckSetttings的实例。</li>
<li>HasFlag的实参可以是多个枚举|运算的结果。</li>
</ul>
<p>用作标志位的枚举常使用Flags特性修饰。<br>
Flags特性会重载枚举的ToString()方法，打印枚举对象时，会打印它包含的各个标志位对应的枚举成员名称，而不是输出一个数字。</p>
<p><img src="https://fire1000.github.io/post-images/1655801975966.png" alt="" loading="lazy"><br>
以上代码，当为CardDeckSetttings添加Flags特性，输出变为：</p>
<pre><code>FancyNumbers
FancyNumbers, Animation
</code></pre>
<p>相同类型的枚举成员之间可以使用比较运算符，但不同类型的枚举不行。</p>
<p>枚举对应.NET的Enum类型，提供以下方法：</p>
<ol>
<li>GetName()方法接收一个枚举类型对象和一个整数，返回一个枚举成员名称。</li>
<li>GetNames()方法接收一个枚举类型对象，返回这个枚举的所有成员名称。</li>
</ol>
<p>GetName()和GetNames()方法示例：<br>
<img src="https://fire1000.github.io/post-images/1655802503144.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第10章 结构 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-10-zhang-jie-gou-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-10-zhang-jie-gou-bi-ji/">
        </link>
        <updated>2022-06-21T07:27:42.000Z</updated>
        <content type="html"><![CDATA[<p>与类不同，结构是值类型。</p>
<p>结构不允许有析构函数。<br>
C#为每个结构隐式提供一个无参实例构造函数，它将每个成员设置为类型的默认值。<br>
无法为结构显式声明无参实例构造函数。</p>
<p>结构同样可以使用new运算符创建实例，但这与是否从堆中分配内存无关。<br>
当结构不使用new运算符创建实例时，数据成员显式赋值后才可以访问，函数成员在所有数据成员显式赋值之后才可以调用。<br>
<img src="https://fire1000.github.io/post-images/1655796922134.png" alt="" loading="lazy"></p>
<p>在结构中字段初始化语句是不允许的。</p>
<p>结构是隐式密封的，不能被继承。因此，不能使用protected、internal、abstract、virtual修饰结构的成员。<br>
结构派生自System.ValueType，System.ValueType派生自object。因此，可以使用new、override修饰符，隐藏和覆写System.ValueType的成员。</p>
<p>预定义简单类型(int等)在.NET中都由结构实现。</p>
<p>结构可以实现接口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第9章 语句 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-9-zhang-yu-ju-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-9-zhang-yu-ju-bi-ji/">
        </link>
        <updated>2022-06-21T02:37:24.000Z</updated>
        <content type="html"><![CDATA[<p>与C/C++不同，条件语句和循环语句中测试表达式必须返回bool值，不能是数字。</p>
<p>跳转语句包括return、break、continue、goto、throw。</p>
<p>与C/C++不同，switch语句的每个分支(case或default)通常都必须使用跳转语句结尾，仅当不包含任何语句时例外。<br>
<img src="https://fire1000.github.io/post-images/1655792065007.png" alt="" loading="lazy"></p>
<p>break语句仅能在switch、while、do、for、foreach语句中使用，跳出最内层的封装语句(innermost enclosing statement)。<br>
continue语句仅能在while、do、for、foreach语句中使用，跳转到最内层的封装语句的起始处。</p>
<p>标签语句定义一个标签，标签的作用域为作处的块内。</p>
<pre><code>Indentifier: Statement
</code></pre>
<p>goto语句可以跳转到一个标签。</p>
<pre><code>goto Identifier;
</code></pre>
<p>goto语句还可以跳转到switch语句中的case和default标签。</p>
<pre><code>goto cae ConstantExpression;
goto default;
</code></pre>
<p>using语句是语法糖，用于确保在资源使用完毕之后，调用Dispose()方法。<br>
资源指实际了System.IDisposable接口的类型。<br>
System.IDisposable接口只有一个方法，就是Dispose()。<br>
using语句有两种形式：<br>
<img src="https://fire1000.github.io/post-images/1655795356426.png" alt="" loading="lazy"></p>
<ul>
<li>using语句可以用于多个同类型的资源，以逗号分隔。<br>
<img src="https://fire1000.github.io/post-images/1655795401127.png" alt="" loading="lazy"></li>
<li>第二种形式资源使用之前可能已经被释放，不推荐。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第8章 表达式和运算符 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-8-zhang-biao-da-shi-he-yun-suan-fu-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-8-zhang-biao-da-shi-he-yun-suan-fu-bi-ji/">
        </link>
        <updated>2022-06-18T03:35:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="表达式">表达式</h2>
<p>表达式除了返回一个值以外的功能，称为副作用，比如分配内存，又比如赋值表达式设置左边操作数的值是它的副作用。</p>
<h2 id="字面值">字面值</h2>
<p>整数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655523693428.png" alt="" loading="lazy"><br>
整数字面值的类型是，后辍对应的类型中，能容纳这个值的最小的类型。</p>
<p>浮点数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655633313375.png" alt="" loading="lazy"></p>
<p>字符字面值有四种：<br>
<img src="https://fire1000.github.io/post-images/1655634956854.png" alt="" loading="lazy"><br>
\x和\u都后跟4位十六进制数。</p>
<ul>
<li>经测试\x和\u完全没有区别，编码为UCS-2 BE。'\x4E2D'和'\u4E2D'都输出<code>中</code>，测试环境为Intel CPU。</li>
</ul>
<p>转义序列：<br>
<img src="https://fire1000.github.io/post-images/1655635304774.png" alt="" loading="lazy"></p>
<p>@前辍的字符串是逐字字符串：</p>
<ol>
<li>转义序列不被求值。</li>
<li>支持换行符。</li>
<li>连续的两个引号解释为一个引号。</li>
</ol>
<p>除了rst3和vst3，以下逐字字符串与普通字符串有完全相同的输出：<br>
<img src="https://fire1000.github.io/post-images/1655710704418.png" alt="" loading="lazy"></p>
<p>C#编译器使得相同的字符串字面值占堆中同一块内存。</p>
<h2 id="运算符">运算符</h2>
<p>运算符优先级：<br>
<img src="https://fire1000.github.io/post-images/1655710924275.png" alt="" loading="lazy"></p>
<p>运算符结合性：<br>
<img src="https://fire1000.github.io/post-images/1655710956571.png" alt="" loading="lazy"></p>
<p>C#求余运算符%支持浮点数。</p>
<p>与C/C++不同，C#中数字不具有布尔意义。<br>
相等运算符比较引用类型时，除了比较string和委托使用深比较，其他都使用浅比较。</p>
<ul>
<li>浅比较只比较引用的地址。</li>
<li>深比较只比较引用指向的内存中的数据。</li>
</ul>
<p>C#中&amp;&amp;和||是短路运算符，当左边的表达式足以确定返回值时，右边的表达式不求值。</p>
<p>C#中右移运算符，对于有符号整数符号位填充，对于无符号整数0填充。</p>
<p>if...else语句执行两个行为其中一个，条件运算符返回两个值其中一个。</p>
<h2 id="自定义类型转换">自定义类型转换</h2>
<p>C#支持自定义类型转换，隐式转换由编译器依据上下文自行调用，显式转换在使用强制转换运算符时调用。<br>
自定义类型转换的语法：<br>
<img src="https://fire1000.github.io/post-images/1655720026416.png" alt="" loading="lazy"></p>
<ul>
<li>显式转换使用explicit关键字，隐式转换使用implicit关键字。</li>
<li>无论是显式转换还是隐式转换，public和static修饰符都是必需的。</li>
<li>源类型与目标类型不能相同。</li>
</ul>
<h2 id="运算符重载">运算符重载</h2>
<p>运算符重载的参数至少要有一个是所属的类或结构类型，语法如下：<br>
<img src="https://fire1000.github.io/post-images/1655720993031.png" alt="" loading="lazy"></p>
<ul>
<li>public和static修饰符是必需的。</li>
</ul>
<p>可重载的运算符：<br>
<img src="https://fire1000.github.io/post-images/1655721044770.png" alt="" loading="lazy"></p>
<ul>
<li>强制转换计入自定义类型转换，不计入运算符重载。</li>
</ul>
<h2 id="typeof运算符">typeof运算符</h2>
<p>typeof运算符与实例的GetType()方法相同，返回System.Type对象，直接打印这个对象会输出类型名。通过GetFields()和GetMethods()方法，还可以获得字段成员和方法成员信息：<br>
<img src="https://fire1000.github.io/post-images/1655722585884.png" alt="" loading="lazy"></p>
<ul>
<li>FieldInfo和MethodInfo在System.Reflection命名空间中定义。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fire1000.github.io/post-images/1655722663460.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第7章 类和继承 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-7-zhang-lei-he-ji-cheng-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-7-zhang-lei-he-ji-cheng-bi-ji/">
        </link>
        <updated>2022-06-17T10:37:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="object">object</h2>
<p>object是唯一的非派生类(derived class)。除了object，所有的类都是派生类。<br>
类声明时，不显式派生自object，那么它隐式派生自object。</p>
<h2 id="隐藏">隐藏</h2>
<p>派生类无法删除从基类(base class)继承的成员，但可以隐藏它。</p>
<ol>
<li>声明相同名称的成员，可以隐藏字段、常量、属性。</li>
<li>声明相同签名的成员，可以隐藏方法。签名不包含返回值类型。</li>
</ol>
<p>隐藏可以显式使用new关键字，也可以不使用。</p>
<p>使用基类访问(base access)可以访问被隐藏的成员：base关键字+点+成员名称。<br>
使用基类的引用访问派生类，也可以访问隐藏的成员。</p>
<h2 id="覆写">覆写</h2>
<p>在基类中使用virtual声明一个函数成员，在派生类中使用override声明相同签名、相同返回值类型、相同可访问性的函数成员，则基类的被覆写，无法再被访问。无论使用基类访问还是基类引用访问，访问的都是派生类的函数成员。<br>
无法覆写静态成员。<br>
支持覆写的函数成员类型有方法、属性、索引器、事件。<br>
使用override声明的函数成员支持被覆写，调用时访问最高派生(most-derived)版本。</p>
<h2 id="实例化顺序">实例化顺序</h2>
<p>派生类对象实例化时，先初始化派生类的实例成员，再调用基类的实例构造函数，最后调用派生类的实例构造函数。<br>
因此，在实例构造函数中调用virtual函数成员是极不推荐的，因为当被覆写时，它调用派生类对应的函数成员，而这时派生类的实例构造函数还没有被调用。</p>
<h2 id="构造函数初始化语句">构造函数初始化语句</h2>
<p>构造函数初始化语句有两种形式：<br>
<img src="https://fire1000.github.io/post-images/1655514692603.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655514699431.png" alt="" loading="lazy"><br>
base形式允许派生类的实例构造函数，指定在它之前调用的基类实例构造函数。如果一个实例构造函数不带base形式的构造函数初始化语句，那么在它之前调用的基类无参实例构造函数，以下两种形式是等价的：<br>
<img src="https://fire1000.github.io/post-images/1655515353320.png" alt="" loading="lazy"><br>
this形式允许在一个实例构造函数调用之前，调用另一个实例构造函数。</p>
<h2 id="访问修饰符">访问修饰符</h2>
<p>类的访问修饰符只有两个级别：</p>
<ol>
<li>public：允许所有程序集访问。</li>
<li>internal：只允许所属的程序集访问。</li>
</ol>
<ul>
<li>当类的访问修饰符缺省时，隐式声明为internal。</li>
</ul>
<p>成员的访问修饰符有5个级别：public、private、protected、internal、protected internal。<br>
<img src="https://fire1000.github.io/post-images/1655519237762.png" alt="" loading="lazy"><br>
当成员访问修饰符缺省时，隐式声明为private。<br>
成员不能比它所属的类或结构有更高的可访问性，可访问性级别如图：<br>
<img src="https://fire1000.github.io/post-images/1655519285002.png" alt="" loading="lazy"></p>
<h2 id="abstract">abstract</h2>
<p>abstract声明的函数成员是抽象的，抽象成员只能在抽象类中声明。<br>
抽象成员与虚成员的对比：<br>
<img src="https://fire1000.github.io/post-images/1655519619825.png" alt="" loading="lazy"></p>
<p>abstract声明的类是抽象类，抽象类不能实例化，只能作为基类。<br>
抽象类的派生类可以是抽象类。<br>
抽象类可以声明非抽象成员。</p>
<h2 id="密封类">密封类</h2>
<p>sealed声明的类是密封类，与抽象类相反，密封类不能作为基类。</p>
<h2 id="静态类">静态类</h2>
<p>static声明的类是静态类。</p>
<ol>
<li>静态类的成员必须是静态的。</li>
<li>静态类是隐式sealed的，不能被继承。</li>
</ol>
<h2 id="扩展方法">扩展方法</h2>
<p>扩展方法允许在类或结构外声明一个方法，调用时看起来像这个类或结构的成员。<br>
<img src="https://fire1000.github.io/post-images/1655520389567.png" alt="" loading="lazy"></p>
<h2 id="命名约定">命名约定</h2>
<p><img src="https://fire1000.github.io/post-images/1655520543666.png" alt="" loading="lazy"><br>
微软官方推荐将Camel大小写作为私有和受保护字段的名称。但作者认为前辍下划线更实用，并且微软在代码中也大量使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第6章 深入理解类 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-6-zhang-shen-ru-li-jie-lei-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-6-zhang-shen-ru-li-jie-lei-bi-ji/">
        </link>
        <updated>2022-06-17T02:13:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="成员声明">成员声明</h2>
<p>类成员声明必须按特性(attribute)、修饰符、核心声明的顺序排列。</p>
<h2 id="静态成员">静态成员</h2>
<p>static声明的成员是静态的。<br>
在类和结构外部，必须使用类名和结构名才能访问静态成员。<br>
静态字段在堆上分配内存，占所属的类和结构的内存，与它们的实例的内存分开。<br>
静态字段在访问所属类和结构的任意静态字段时初始化。<br>
静态函数只能访问所属类和结构的静态成员，不能访问实例成员。<br>
类成员中，只有以下勾选的类型可以声明为静态：<br>
<img src="https://fire1000.github.io/post-images/1655447741107.png" alt="" loading="lazy"></p>
<h2 id="常量">常量</h2>
<p>与C/C++不同，C#没有全局常量。<br>
C#中常量不分配内存，在编译时替换为它的值，类似于C/C++中的宏#define。<br>
常量成员，在类和结构外部，必须使用类名和结构名才能访问，与静态成员一样。<br>
常量成员不能声明为static。</p>
<h2 id="属性">属性</h2>
<p>属性是函数成员，不分配内存，有两个访问器set和get。</p>
<ol>
<li>set访问器有一个隐式的属性类型的值参数value，返回void。</li>
<li>get访问器没有参数，返回属性类型。</li>
<li>set与get访问器至少定义一个，只定义set访问器是只写的，只定义get访问器是只读的。</li>
</ol>
<p>一个public属性关联一个private字段，这个字段被称为后备字段。属性与后备字段有两种常见的命名约定：<br>
<img src="https://fire1000.github.io/post-images/1655448662449.png" alt="" loading="lazy"></p>
<p>与public字段相比，属性更为推荐，提供更多的功能，更便于修改。</p>
<p>C#提供自动实现属性(automatically implemented property)：当声明属性时，set与get访问器同时存在，并且方法体为分号时，编译器为属性创建隐藏的后备字段，这个字段只能通过这个属性访问。</p>
<h2 id="构造函数">构造函数</h2>
<p>构造函数(constructor)与类名相同，没有返回值类型。<br>
实例构造函数支持重载。<br>
当一个类没有显式声明实例构造函数时，编译器为这个类定义默认构造函数。默认构造函数没有参数，方法体为空，被public修饰。<br>
new关键字调用实例构造函数。<br>
static声明的构造函数是静态的，一个类只有一个静态构造函数。静态构造函数不能有参数，不能有访问修饰符。<br>
静态构造函数无法显式调用，当类被实例化时，或访问类的静态成员时，在这些操作被执行之前被调用。</p>
<h2 id="对象初始化语句">对象初始化语句</h2>
<p>对象初始化语句有两种形式：<br>
<img src="https://fire1000.github.io/post-images/1655454987492.png" alt="" loading="lazy"><br>
对象初始化语句在构造函数之后调用。</p>
<h2 id="析构函数">析构函数</h2>
<p>析构函数(destructor)用于在实例被销毁之前清理和释放非托管资源。因此，如果只使用.NET类，则不需要编写析构函数。</p>
<h2 id="readonly">readonly</h2>
<p>readonly只能修饰字段，可以是实例字段，也可以是静态字段。<br>
readonly声明的字段，在初始化后，便不能再修改。可以通过initializer初始化，也可以在构造函数中初始化。初始值可以是运行时确定的值。<br>
与const不同，readonly分配内存。</p>
<h2 id="this">this</h2>
<p>this关键字，在类中使用是对当前实例的引用。只能在以下成员中使用：</p>
<ol>
<li>实例构造函数</li>
<li>实例方法。</li>
<li>属性和索引器的实例访问器。<br>
this常用于区分类的成员与本地变量或参数，和作为调用方法的实参。</li>
</ol>
<h2 id="索引器">索引器</h2>
<p>索引器与属性相似，但表示多个数据成员。<br>
索引器只能实例成员，不能声明为static。<br>
索引器没有后备字段的概念，因此也不支持自动实现属性。</p>
<p>索引器与属性的声明差异：<br>
<img src="https://fire1000.github.io/post-images/1655458393707.png" alt="" loading="lazy"><br>
索引器的参数，至少存在一个，支持存在多个。</p>
<p>索引器通过类名和结构名后跟方括号，并在方括号中传递实参访问。<br>
索引器支持重载。</p>
<h2 id="访问器的访问修饰符">访问器的访问修饰符</h2>
<p>访问器支持访问修饰符，但存在限制：</p>
<ol>
<li>仅当属性或索引器同时存在set和get访问器时，才能其中之一有访问修饰符。</li>
<li>访问器的访问修饰符必须比所属成员的的访问级别有更严格的限制性。</li>
</ol>
<p>访问修饰符的限制性：<br>
<img src="https://fire1000.github.io/post-images/1655458929900.png" alt="" loading="lazy"></p>
<h2 id="分部类">分部类</h2>
<p>partial class声明的类是分部类，分部类支持将一个类的声明分割成多个部分，这些部分可以不在一个文件内。</p>
<h2 id="分部方法">分部方法</h2>
<p>分部方法指将一个方法的声明拆分成两个部分，这些部分可以在分部类的不同部分中声明。</p>
<ol>
<li>定义部分：包含签名和返回值类型，方法体为分号。</li>
<li>实现部分：包含签名和返回值类型，方法体与普通方法相同。</li>
</ol>
<p>分部方法存在以下限制：</p>
<ol>
<li>定义部分与实现部分的签名和返回值类型必须相同。</li>
<li>返回值类型必须为void。</li>
<li>void之前必须为partial。</li>
<li>不能包含访问修饰符，分部方法是隐式private的。</li>
<li>不能包含out参数。</li>
</ol>
<p>允许只存在定义部分，这样编译器将这个方法的声明和调用全部移除。<br>
不允许只存在实现部分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第5章 方法 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-5-zhang-fang-fa-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-5-zhang-fang-fa-bi-ji/">
        </link>
        <updated>2022-06-16T09:16:17.000Z</updated>
        <content type="html"><![CDATA[<p>var关键字：</p>
<ol>
<li>只能用于本地变量。</li>
<li>只能用于包含initializer的变量声明，编译器依据initializer推断变量的类型。</li>
<li>一旦编译器推断出变量的类型，它就是固定不变的。</li>
</ol>
<p>与C/C++不同，C#不能在一个名称的作用域内声明相同的名称，即使这个相同的名称在嵌套块内部。</p>
<p>常量：</p>
<ol>
<li>通过const关键字声明。与C/C++不同，const不是修饰符，是核心声明的一部分，必须紧挨类型名，放在类型名之前。</li>
<li>必须包含initializer。初始值必须在编译期确定，因此它不能是某个对象的引用，可以是null。</li>
<li>声明后值不能改变。</li>
</ol>
<p>值参数：</p>
<ol>
<li>默认类型的参数。</li>
<li>在栈上为形参分配内存。</li>
<li>将实参的值拷贝给形参。实参可以是表达式。如果实参是变量，则必须已初始化。</li>
</ol>
<p>引用参数：</p>
<ol>
<li>形参与实参都使用ref修饰。</li>
<li>实参必须是变量，并且必须已初始化。</li>
<li>不为形参分配内存，形参是实参的别名。</li>
</ol>
<p>输出参数：</p>
<ol>
<li>形参与实参都使用out修饰。</li>
<li>实参必须是变量，不需要初始化。</li>
<li>不为形参分配内存，形参是实参的别名。</li>
<li>形参在函数内部被读取之前，必须先赋值。</li>
<li>形参在函数返回之前，必须赋值。</li>
</ol>
<p>参数数组：</p>
<ol>
<li>形参使用params修饰。</li>
<li>形参的类型必须为一维数组。</li>
<li>一个函数只允许有一个参数数组，并且必须作为最后一个形参。</li>
<li>形参对应0或1或多个参数数组元素类型的实参，或一个参数数组类型的实参。</li>
<li>在栈上为参数数组的引用部分分配内存，在堆上为参数数组的元素分配内存。</li>
</ol>
<p>值参数、引用参数、输出参数、参数数组简单对比：<br>
<img src="https://fire1000.github.io/post-images/1655378112817.png" alt="" loading="lazy"></p>
<p>一个类中可以拥有多个重名的方法，称为方法重载(method overload)。注意与方法覆写(method overload)区分。<br>
方法重载的签名(signature)必须不同，签名包括名称、参数个数、参数的类型和顺序，参数修饰符，签名不包括返回值类型、参数名称。一个类拥有签名相同，返回值类型不同的方法会报错。</p>
<p>位置参数：形参与实参位置一一对应。</p>
<p>命名参数：实参以形参名、冒号、实参值的方式给出。形参与实参位置不需要对应。<br>
<img src="https://fire1000.github.io/post-images/1655379920541.png" alt="" loading="lazy"><br>
命名参数可以与位置参数一起使用，但位置参数必须写在命名参数之前。</p>
<p>可选参数：指函数声明时，设定默认值的形参，这些形参在函数调用时可以省略对应的实参。</p>
<ol>
<li>可选参数只能是值参数。</li>
<li>可选参数的默认值在编译期确定，因此引用类型只能为null。</li>
<li>可选参数在形参列表中，必须位于必填参数之后，参数数组之前。(必填参数和参数数组可以不存在)</li>
<li>函数调用时，使用位置参数，则可选参数对应的实参必须从后向前省略，使用命名参数无此限制。</li>
</ol>
<p>每个函数调用时，会创建一个栈帧并入栈，函数调用结束时弹栈。<br>
栈帧包含返回地址(函数返回时，继续执行的地址)，为形参分配的内存，其他函数调用相关的管理数据项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第4章 类的基本概念 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-4-zhang-lei-de-ji-ben-gai-nian-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-4-zhang-lei-de-ji-ben-gai-nian-bi-ji/">
        </link>
        <updated>2022-06-16T08:53:34.000Z</updated>
        <content type="html"><![CDATA[<p>C#类有9种成员类型：<br>
<img src="https://fire1000.github.io/post-images/1655369733910.png" alt="" loading="lazy"></p>
<p>与C/C++不同，C#不能在类型外部声明变量和函数。</p>
<p>new关键字为引用类型的数据部分在堆上分配内存，返回地址。为值类型分配内存，返回拷贝。</p>
<p>静态成员是与类相关，与实例无关的成员。</p>
<p>类的成员的访问修饰符缺省时，隐式声明为private。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第3章 类型、存储和变量 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-3-zhang-lei-xing-cun-chu-he-bian-liang-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-3-zhang-lei-xing-cun-chu-he-bian-liang-bi-ji/">
        </link>
        <updated>2022-06-16T06:30:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据类型">数据类型</h2>
<p>C程序是一组函数和数据类型，C++程序是一组函数和类，C#程序是一组类型声明。<br>
可执行的C#程序的类型声明中必须包含一个存在Main方法的类。命名空间是将类型声明分组的方法。</p>
<p>C#提供16种预定义类型：<br>
<img src="https://fire1000.github.io/post-images/1655362331322.png" alt="" loading="lazy"></p>
<ul>
<li>与C/C++不同，C#中数值类型不具有布尔意义。</li>
<li>char为2 byte，容纳一个UCS-2字符。</li>
<li>decimal是高精度小数类型，可以准确表示分数，常用于货币计算。</li>
</ul>
<p>C#中预定义类型是底层.NET类型的别名：<br>
<img src="https://fire1000.github.io/post-images/1655363080438.png" alt="" loading="lazy"></p>
<p>C#提供6种自定义类型：class、struct、array、enum、delegate、interface。</p>
<h2 id="栈和堆值类型和引用类型">栈和堆，值类型和引用类型</h2>
<p>CLR的GC(Garbage Collector，垃圾收集器)会自动清除堆中无主的对象。</p>
<p>引用类型需要存储两部分内存：引用部分和数据部分。其中数据部分总位于堆中。</p>
<p>C#的值类型与引用类型：<br>
<img src="https://fire1000.github.io/post-images/1655364837215.png" alt="" loading="lazy"></p>
<h2 id="变量">变量</h2>
<p>C#提供4种变量：<br>
<img src="https://fire1000.github.io/post-images/1655365201631.png" alt="" loading="lazy"></p>
<p>变量的存储位置，声明时没有initializer是否自动初始化，如图：<br>
<img src="https://fire1000.github.io/post-images/1655365674832.png" alt="" loading="lazy"></p>
<h2 id="dynamic">dynamic</h2>
<p>.NET语言中，IronPython、IronRuby等使用动态类型(运行时才被解释)。C#程序要访问这些语言编写的程序集中的变量，只能使用dynamic类型。</p>
<p>C#编译器不对dynamic变量进行类型检查，它将变量与它相关的操作信息打包。在运行时，对这些信息进行检查，以确保操作与变量的实际类型一致。否则，将在运行时抛出异常。</p>
]]></content>
    </entry>
</feed>