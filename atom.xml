<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fire1000.github.io</id>
    <title>Fly_Fire1000的博客</title>
    <updated>2022-06-27T14:42:45.787Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fire1000.github.io"/>
    <link rel="self" href="https://fire1000.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://fire1000.github.io/images/avatar.png</logo>
    <icon>https://fire1000.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Fly_Fire1000的博客</rights>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第20章 异步编程 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-20-zhang-yi-bu-bian-cheng-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-20-zhang-yi-bu-bian-cheng-bi-ji/">
        </link>
        <updated>2022-06-23T09:40:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程">线程</h2>
<p>启动程序时，系统会在内存中创建一个进程，进程是运行程序的资源的集合，包含虚地址空间、文件句柄等。<br>
在进程内部，系统会创建一个线程，从Main()方法开始执行。</p>
<p>默认情况下，一个进程只包含一个线程。<br>
一个线程可以派生出其他线程，因此一个进程可以包含多个线程，这些线程共用这个进程的资源。<br>
系统为处理器执行规划的单位是线程，而不是进程。</p>
<p>System.Diagnostics命名空间中的Stopwatch类，可以用来测量一段代码执行的时间。</p>
<pre><code>Stopwatch sw = new Stopwatch();
sw.Start();
// todo...
Console.WriteLine(sw.Elapsed.TotalMilliseconds);
</code></pre>
<h2 id="asyncawait">async/await</h2>
<p>C# 5.0引入构建异步方法的新特性：async/await，示例：<br>
<img src="https://fire1000.github.io/post-images/1655983871884.png" alt="" loading="lazy"><br>
上面例子的执行流程：</p>
<ol>
<li>正常执行，直到在async方法中，遇到await表达式：wb.DownloadStringTaskAsync()。</li>
<li>因为wb.DownloadStringTaskAsync()会创建一个新的线程，所以async方法中后续代码都在这个新创建的线程中执行。(为了便于区分，将之前的执行线程称为主线程，新创建的线程称为子线程。下同)当子线程创建完毕，返回一个占位符给主线程，这里是Task&lt;int&gt;类型的对象t1和t2。
<ul>
<li>如果await表达式不会创建一个新的线程，那么会继续正常执行，就像await关键字不存在一样。</li>
</ul>
</li>
<li>主线程与两个子线程同时执行。</li>
<li>主线程遇到t1.Result。判断返回t1的async方法，在它对应的子线程中是否执行完毕。如果执行完毕，则t1.Result获取async方法的返回值。如果未执行完毕，则主线程挂起，直到t1对应async方法执行完毕，再从t1.Result获取async方法的返回值。
<ul>
<li>async方法执行完毕时，它对应的子线程自行销毁。</li>
</ul>
</li>
<li>t2.Result的流程与t1.Result相同。</li>
</ol>
<p>async方法支持三种返回值类型：Task&lt;T&gt;、Task、void。</p>
<ol>
<li>返回Task&lt;T&gt;的async方法，需要return一个T类型的值。</li>
<li>返回Task、void的async方法，不需要return任何值，随使return了某个值也会被忽略。</li>
</ol>
<p>Thread.Sleep()方法可以挂起当前的线程，参数以毫秒为单位。</p>
<p>await表达式中，await修饰的表达式必须是awaitable类型的对象。<br>
awaitable类型包含GetAwaiter()方法，返回一个awaiter类型对象。<br>
awaiter类型对象包含以下成员：</p>
<pre><code>bool IsCompleted {get;};
void OnCompleted(Action);
</code></pre>
<p>awaiter类型对象还包含<code>void GetResult();</code>或<code>T GetResult();</code>(T为任意类型)。</p>
<p>Task类(包含泛型版本，下同)是awaitable类型，因此不需要手动创建awaitable类型。<br>
Task.Run()方法返回一个Task类对象。它创建一个子线程，执行作为参数的委托，它的重载如下：<br>
<img src="https://fire1000.github.io/post-images/1656231584367.png" alt="" loading="lazy"></p>
<p>System.Threading.Tasks命名空间中，CancellationToken和CancellationTokenSource类用于取消一个正在执行的async方法，用法如下：</p>
<ol>
<li>首先实例化一个CancellationTokenSource对象，通过它的Token属性获得一个CancellationToken对象。</li>
<li>将这个CancellationToken对象传递给async方法，在方法内部不断手动检测它的IsCancellationRequested属性，如果为false则继续执行，如果为true则取消方法，即return。</li>
<li>调用CancellationTokenSource对象的Cancel()方法，会将从它获取的CancellationToken对象的IsCancellationRequested属性置为true，从而达到取消async方法的目的。</li>
</ol>
<ul>
<li>注意：IsCancellationRequested属性一旦被置为true，就不能再修改，因此CancellationToken对象是一次性的。</li>
</ul>
<p>在async方法中，当使用try..catch语句捕获到await表达式中的异常时，这个async方法返回的Task类对象的Status属性为RanToCompletion，表示执行完毕，IsFaulted属性为False，表示没有未处理的异常。</p>
<p>阻塞主线程，等待async方法执行完毕：</p>
<ol>
<li>async方法返回的Task类对象的Wait()方法可以阻塞主线程，直到对应的async方法执行完毕。效果类似于访问它的Result属性，只是不返回一个值。</li>
<li>Task类还提供了两个静态方法WaitAll()和WaitAny()，参数是Task类数组，WaitAll()用于阻塞主线程，直到所有数组元素对应的async方法执行完毕，WaitAny()则用于阻塞主线程，直到任意一个数组元素对应的async方法执行完毕。</li>
</ol>
<p>WaitAll()和WaitAny()方法还提供以下重载，用于接收取消信号和设置超时的处理：<br>
<img src="https://fire1000.github.io/post-images/1656295904070.png" alt="" loading="lazy"></p>
<p>创建一个子线程，直到目标async方法执行完毕，才开始执行：Task类为此提供了两个静态方法WhenAll()和WhenAny()，参数是Task类数组，WhenAll()用于所有数组元素对应的async方法都执行完毕才开始执行，WaitAny()则用于任意一个数组元素对应的async方法执行完毕就开始执行。</p>
<ul>
<li>WhenAll()和WhenAny()方法必须使用await修饰。</li>
</ul>
<p>Task.Delay()方法，用于阻塞调用它的async方法所处的线程，参数以毫秒为单位，提供以下重载：</p>
<ul>
<li>Task.Delay()方法必须使用await修饰。<br>
<img src="https://fire1000.github.io/post-images/1656296534286.png" alt="" loading="lazy"></li>
</ul>
<p>WPF程序从消息泵获取用户输入。因此，如果处理用户输入的时间过长，程序会卡住，用户在程序卡住时的全部操作，会在程序恢复时，一瞬间完成。</p>
<p>Task.Yield()方法，创建一个子线程，将async方法的后续代码(直到下一个会创建线程的await表达式之前)都放到这个线程中执行。</p>
<ul>
<li>Task.Yield()方法必须使用await修饰。</li>
</ul>
<p>async方法支持Lambda表达式，需要在表达式前添加async关键字。</p>
<h2 id="backgroundworker类">BackgroundWorker类</h2>
<p>BackgroundWorker类的对象用于为一段目标代码创建一个后台线程，当目标代码执行完毕，或提前退出时，销毁这个线程：<br>
<img src="https://fire1000.github.io/post-images/1656316572502.png" alt="" loading="lazy"></p>
<p>BackgroundWorker类的用法：</p>
<ol>
<li>创建一个BackgroundWorker类的对象。</li>
<li>为它的WorkerReportsProgress和WorkSupportsCancellation属性赋值。
<ol>
<li>WorkerReportsProgress表示用户是否可以调用它的ReportProgress()方法报告目标代码执行进度。</li>
<li>WorkSupportsCancellation表示用户是否可以调用它的CancelAsync()方法，使目标代码提前退出。</li>
</ol>
</li>
<li>为它的三个事件DoWork、ProgressChanged、RunWorkerCompleted关联方法。
<ol>
<li>当用户调用它的RunWorkerAsync()方法时，这个方法会创建一个线程，并触发DoWork事件。通常不会在它的IsBusy属性为true时调用RunWorkerAsync()方法，因为这表示已经存在创建的线程。DoWork事件关联的方法就是目标代码。</li>
<li>在目标代码中，通常会调用BackgroundWorker类对象的ReportProgress()方法报告进度。ReportProgress()方法会触发它的ProgressChanged事件。</li>
<li>在目标代码中，还应该不断检查CancellationPending属性，当这个属性为true时及时return。</li>
<li>当目标代码return后，RunWorkerCompleted事件会触发，在这个事件关联的方法中，通常也会检查CancellationPending属性，以确定目标代码是执行完毕，还是提前退出。在这个事件关联的方法执行完毕后，线程会自行销毁。</li>
</ol>
</li>
<li>调用它的RunWorkerAsync()方法，开始执行目标代码。</li>
<li>在目标代码执行过程中，可以随时调用BackgroundWorker类对象的CancelAsync()方法，这个方法会使得它的CancellationPending属性为true，从而使得目标代码提前退出。</li>
</ol>
<h2 id="并行库task-parellel-library">并行库(Task Parellel Library)</h2>
<p>在System.Threading.Tasks命名空间中提供了Parallel.For和Parallel.ForEach两个并行循环。</p>
<p>Parallel.For有12个重载，最简单的用法如下：</p>
<pre><code>Parallel.For(0, 15, i =&gt; Console.WriteLine(&quot;The square of {0} is {1}&quot;, i, i * i));
</code></pre>
<ul>
<li>第一个参数是起始索引，第二参数比最后一个索引大1，第三个参数是Action委托。</li>
<li>注意：因为是并行执行的，所以不保证迭代顺序。</li>
</ul>
<p>Parallel.ForEach也有相当多的重载，最简单的用法如下：</p>
<pre><code>string[] squares = new string[] {&quot;We&quot;, &quot;hold&quot;, &quot;these&quot;, &quot;truths&quot;, &quot;to&quot;, &quot;be&quot;, &quot;self-evident&quot;, &quot;that&quot;, &quot;all&quot;, &quot;men&quot;, &quot;are&quot;, &quot;created&quot;, &quot;equal&quot;};
Parallel.ForEach(squares, i =&gt; Console.WriteLine(string.Format(&quot;{0} has {1} letters&quot;, i, i.Length)));
</code></pre>
<ul>
<li>与Parallel.For相同，Parallel.ForEach也不保证迭代顺序。</li>
</ul>
<h2 id="beigninvoke和endinvoke">BeignInvoke和EndInvoke</h2>
<p>委托对象的BeignInvoke()方法可以创建一个线程，在这个线程中调用委托的调用列表中的函数。<br>
BeignInvoke()返回一个AsyncResult对象的IAsyncResult接口引用，IAsyncResult接口的IsCompleted属性可以检查委托是否执行完毕。<br>
BeignInvoke()的前几个参数对应调用委托的形参，最后两个参数依次为callback和state。callback为AsyncCallBack委托类型，接收一个IAsyncResult类型参数返回void。callback在调用委托执行完毕时调用。state参数是object类型，会赋值给callback接收到IAsyncResult类型参数的AsyncState属性，用于传递信息。<br>
<img src="https://fire1000.github.io/post-images/1656338839347.png" alt="" loading="lazy"></p>
<p>委托对象的EndInvoke()方法与BeignInvoke()对应，接收一个BeignInvoke()返回IAsyncResult类型参数，返回BeignInvoke()调用委托的返回值，并清理线程。如果调用EndInvoke()方法时，调用未执行完毕，则挂起EndInvoke()方法所处的线程，直到调用委托执行完毕。<br>
EndInvoke()方法还可以返回委托形参列表中的ref和out参数，只要在EndInvoke()的实参列表中，按相同的顺序排列，并使用对应的ref和out，排列在IAsyncResult类型参数之前。</p>
<p>每一个BeignInvoke()方法调用都必须对应一个EndInvoke()方法调用。</p>
<h2 id="异步编程模式">异步编程模式</h2>
<p>异步编程通常有三种模式：<br>
<img src="https://fire1000.github.io/post-images/1656339885607.png" alt="" loading="lazy"></p>
<p>等待一直到完成(wait-until-done)，与async方法相似，原始线程发起异步方法后，进行一些其他处理。然后检查异步方法是否执行完毕，如果未执行完毕，则阻塞原始线程，直到它执行完毕。</p>
<p>轮询(polling)，原始线程发起异步方法后，定期检查异步方法是否执行完毕，如果未执行完毕，就去处理其他事情，直到它执行完毕才继续。</p>
<p>回调(callback)，原始线程发起异步方法后，就不管异步方法了。直到异步方法执行完毕，在EndInvoke清理线程之前，调用回调方法。</p>
<h2 id="计时器">计时器</h2>
<p>System.Threading命名空间中的Timer类，它由系统的线程池定期开启线程执行给定的方法。调用的方法必须是TimerCallback委托类型，对应的方法形式为<code>void TimerCallback( object state)</code>。<br>
Timer类最常用的构造函数为：</p>
<pre><code>Timer(TimerCallback callback, object state, uint dueTime, uint period)
</code></pre>
<ul>
<li>callback为定期调用的方法。</li>
<li>state是传递给callback的参数。</li>
<li>dueTime为第一次调用时间，设置为0会立刻调用，设置为Timeout.Infinite，则计时器不会工作，即callback一次也不会被调用。</li>
<li>period为两次调用之间的时间间隔，如果设置Timeout.Infinite，则callback只调用一次。</li>
</ul>
<p>.NET BCL还提供了其他几个计时器：<br>
<img src="https://fire1000.github.io/post-images/1656340917567.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第19章 LINQ 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-19-zhang-linq-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-19-zhang-linq-bi-ji/">
        </link>
        <updated>2022-06-23T01:13:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="linq概述">LINQ概述</h2>
<p>LINQ，读作link，语言集成查询(Language Integrated Query)。<br>
对一种数据源类型实现LINQ查询的代码模块，称为LINQ提供程序(provider)。<br>
<img src="https://fire1000.github.io/post-images/1655947196032.png" alt="" loading="lazy"></p>
<p>匿名类型(anonymous type)的语法：<br>
<img src="https://fire1000.github.io/post-images/1655947627367.png" alt="" loading="lazy"><br>
匿名类型只能在函数体中使用。<br>
匿名类型的成员是只读的，无法修改。<br>
如果将匿名类型对象赋值给一个变量，则这个变量只能使用var声明。</p>
<p>匿名类型的成员初始化语句有三种形式：赋值形式、成员访问表达式、标识符：<br>
<img src="https://fire1000.github.io/post-images/1655947864488.png" alt="" loading="lazy"><br>
在赋值形式中，赋值运算符两边的标识符允许重名。</p>
<pre><code>var student = new {Age = Age, Name = Other.Name, Major = Major};
</code></pre>
<p>如果编译器遇到相同的匿名类型(参数名、推断类型、排列顺序都相同)，会复用这个类型，不会创建新的类型。</p>
<p>LINQ查询有两种形式的语法：方法语法(method syntax)和查询语法(query synatx)。<br>
方法语法使用标准的方法调用。方法语法是命令式(imperative)的，指明查询方法调用的顺序。<br>
查询语法和SQL语句相似。查询语法是声明式(declarative)的，只描述要返回的东西。<br>
查询语法在编译时，被编译器翻译为方法调用，因此两者性能上没有差异。但方法语法还提供了一些查询语法没有的功能。</p>
<p>LINQ查询返回的结果称为查询变量，查询变量有两种：可枚举类型(IEnumerable&lt;T&gt;)和标量(scalar)，支持var关键字由编译器推断。<br>
可枚举类型的查询变量：</p>
<ol>
<li>访问查询变量时，才进行查询。每次访问都重新查询</li>
<li>查询之前，如果数据有更新，查询会使用最新的数据。</li>
</ol>
<p>标量的查询变量，立即查询并保存查询结果。</p>
<h2 id="查询表达式">查询表达式</h2>
<p>查询表达式的结构：<br>
<img src="https://fire1000.github.io/post-images/1655952723134.png" alt="" loading="lazy"></p>
<p>from子句的语法：</p>
<pre><code>from Type Item in Items
</code></pre>
<ul>
<li>Type是元素类型。Type是可选的，编译器可以自行推断。</li>
<li>Item是迭代变量</li>
<li>Items是要查询的集合，必须是可枚举类型。</li>
</ul>
<p>与foreach语句不同，from子句不指定集合中的项出现的顺序。</p>
<p>from子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655953390719.png" alt="" loading="lazy"><br>
from子句可以同时存在多个：<br>
<img src="https://fire1000.github.io/post-images/1655955080067.png" alt="" loading="lazy"></p>
<p>from子句，可以后跟任意个join子句：<br>
<img src="https://fire1000.github.io/post-images/1655953646555.png" alt="" loading="lazy"><br>
join子句的语法：</p>
<pre><code>join Identifier in Collection2 on Field1 equals Field2
</code></pre>
<ul>
<li>注意：使用equals关键字，而不是==。</li>
</ul>
<p>join子句用于联结多个集合，创建一个临时的新集合。</p>
<p>let子句可以声明一个变量，语法如下：</p>
<pre><code>let Identifier = Expression
</code></pre>
<p>let子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655956281607.png" alt="" loading="lazy"></p>
<p>where子句可以筛选集合中的项，语法如下：</p>
<pre><code>where BooleanExpression
</code></pre>
<p>where子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655956677842.png" alt="" loading="lazy"></p>
<p>orderby子句用于排序，默认为升序，可以使用ascending和descending关键字显式设置为升序和降序，语法如下：<br>
<img src="https://fire1000.github.io/post-images/1655956848032.png" alt="" loading="lazy"><br>
orderby子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655957268703.png" alt="" loading="lazy"></p>
<p>select...group子句由select子句和group...by子句组成，其中group...by子句是可选的。select子句用于拣选结果，group...by子句用于分组，语法如下：</p>
<pre><code>select Expression
group Expression1 by Expression2
</code></pre>
<p>select子句与匿名类型数组示例：<br>
<img src="https://fire1000.github.io/post-images/1655960346499.png" alt="" loading="lazy"><br>
group...by子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655960763173.png" alt="" loading="lazy"><br>
group...by子依据键(key)分组，返回集合的集合：<br>
<img src="https://fire1000.github.io/post-images/1655960827140.png" alt="" loading="lazy"></p>
<p>into子句可以延续查询，为查询的一部分结果赋予一个名字，在查询的另一部分中使用，语法如下：<br>
<img src="https://fire1000.github.io/post-images/1655960973993.png" alt="" loading="lazy"><br>
into子句示例：<br>
<img src="https://fire1000.github.io/post-images/1655961008187.png" alt="" loading="lazy"></p>
<h2 id="标准查询运算符">标准查询运算符</h2>
<p>标准查询运算符是系列API，被查询的对象必须实现IEnumerable&lt;T&gt;接口，称为序列。</p>
<p>标准查询运算符共47个：<br>
<img src="https://fire1000.github.io/post-images/1655964590361.png" alt="" loading="lazy"></p>
<p>标准查询运算符在System.Linq.Enumerable类中声明，是IEnumerable&lt;T&gt;泛型类的扩展方法。</p>
<p>查询表达式与标准查询运算符可以组合使用：<br>
<img src="https://fire1000.github.io/post-images/1655964962760.png" alt="" loading="lazy"></p>
<p>标准查询运算符中的一些还支持接受泛型委托作为参数：<br>
<img src="https://fire1000.github.io/post-images/1655965110323.png" alt="" loading="lazy"></p>
<p>LINQ还预定了两套泛型委托类型：Func委托和Action委托，各有17个成员，作为标准查询运算符参数的泛型委托类型。<br>
<img src="https://fire1000.github.io/post-images/1655965372038.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655965377200.png" alt="" loading="lazy"></p>
<h2 id="linq-to-xml">LINQ to XML</h2>
<p>标记标签不是文档的数量，是关于数据的数据，称为元数据。</p>
<p>元素是XML的基本要素，元素通过标签划分，元素的数据在开始和关闭标签之间。</p>
<p>XML的标签有两种形式：<br>
<img src="https://fire1000.github.io/post-images/1655966568214.png" alt="" loading="lazy"></p>
<p>XML是树状结构，必须有一个根元素。<br>
与HTML不同，XML的标签区分大小写。<br>
XML的特性是键/值对，值必须包含在引号内(单引号、双引号均可)。<br>
与HTML不同，XML中多个空间不会合并为一个空格。</p>
<p>LINQ to XML提供了一些类，其中最重要的是XElement、XAttribute和XDocument：<br>
<img src="https://fire1000.github.io/post-images/1655967079991.png" alt="" loading="lazy"><br>
图中的类除了XAttribute以外，都从XNode类继承。</p>
<p>创建、保存、加载、打印XML示例：<br>
<img src="https://fire1000.github.io/post-images/1655967440547.png" alt="" loading="lazy"></p>
<p>查询XML的方法：<br>
<img src="https://fire1000.github.io/post-images/1655967639730.png" alt="" loading="lazy"><br>
查询XML示例：<br>
<img src="https://fire1000.github.io/post-images/1655969019095.png" alt="" loading="lazy"></p>
<p>操作XML的方法：<br>
<img src="https://fire1000.github.io/post-images/1655969092176.png" alt="" loading="lazy"><br>
操作XML示例：<br>
<img src="https://fire1000.github.io/post-images/1655969354370.png" alt="" loading="lazy"></p>
<p>在XElement构造函数中包含XAttribute构造函数可以添加特性。<br>
XAttribute构造函数有两种形式，一种是接受name和value，另一种是接受XAttribute的引用。<br>
在XElement节点调用Attribute()方法，传递特性名可以获取特性。<br>
XAttribute类的Remove()方法可以移除特性。<br>
在XElement节点，调用SetAttributeValue()方法，将某个特性的值设置为null，同样可以移除这个特性。SetAttributeValue()方法还可以改变一个特性的值。</p>
<p>XComment节点是注释。<br>
XDeclaration节点是XML的声明，包含XML版本号、字符编码和是否依赖外部引用。<br>
XProcessingInstruction用于提供XML如何被使用和翻译的额外数据，如关联一个样式表。<br>
XComment、XDeclaration、XProcessingInstruction使用示例：<br>
<img src="https://fire1000.github.io/post-images/1655970171641.png" alt="" loading="lazy"></p>
<p>LINQ查询XML示例如下：<br>
<img src="https://fire1000.github.io/post-images/1655970482026.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655970487172.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第18章 枚举器与迭代器 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-18-zhang-mei-ju-qi-yu-die-dai-qi-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-18-zhang-mei-ju-qi-yu-die-dai-qi-bi-ji/">
        </link>
        <updated>2022-06-22T09:08:29.000Z</updated>
        <content type="html"><![CDATA[<p>foreach只支持遍历可枚举类型(enumerable type或enumerable)。<br>
可枚举类型指拥有GetEnumerator()方法的类型，GetEnumerator()返回枚举器(enumerator)对象。枚举器可以依次返回集合中的项。<br>
foreach从可枚举类型中通过GetEnumerator()方法获取枚举器，再将枚举器返回的每一项作为迭代变量(iteration variable)。</p>
<p>枚举器是实现了IEnumerator接口或它的泛型版本的类型的对象。<br>
IEnumerator接口包含Current属性和MoveNext()、Reset()方法：<br>
<img src="https://fire1000.github.io/post-images/1655890295433.png" alt="" loading="lazy"><br>
枚举器的初始状态，位置为-1，即集合的第一个元素之前。<br>
访问枚举器时，总是先调用MoveNext()，再访问Current。<br>
当枚举器的位置在最后一个元素之后，MoveNext()返回false，否则返回true。</p>
<p>使用foreach时，编译器生成与以下代码相似的CIL代码：<br>
<img src="https://fire1000.github.io/post-images/1655890685365.png" alt="" loading="lazy"></p>
<p>IEnumerable接口只有一个成员：GetEnumerator()方法。因此实现了IEnumerable接口的类型为可枚举类型。</p>
<ul>
<li>注意：只要拥有GetEnumerator()方法，不实现IEnumerable接口，也是可枚举类型。</li>
</ul>
<p>与IEnumerator接口一样，IEnumerable接口也存在泛型版本。</p>
<p>非泛型的IEnumerator接口，Current属性返回object类型，因此不是类型安全的。泛型的IEnumerator接口，Current属性返回实际类型，是类型安全的，推荐使用。</p>
<p>泛型的IEnumerator接口不仅实现了非泛型的IEnumerator接口，还实现了IDisposable接口：<br>
<img src="https://fire1000.github.io/post-images/1655892779301.png" alt="" loading="lazy"><br>
泛型的IEnumerable接口实现了非泛型的IEnumerable接口：<br>
<img src="https://fire1000.github.io/post-images/1655892852477.png" alt="" loading="lazy"></p>
<p>C# 2.0还引入了迭代器(iterator)。<br>
依据返回值的类型，迭代器可以生成枚举器或可枚举类型。<br>
<img src="https://fire1000.github.io/post-images/1655897299574.png" alt="" loading="lazy"><br>
yield return语句指定集合的下一项。<br>
yield break语句指定集合没有下一项。<br>
使用迭代器需要引入System.Collections.Generic命名空间。<br>
迭代器生成的枚举器没有实现Reset()方法，调用Reset()方法时抛出System.NotSupportedException异常。<br>
迭代器生成的枚举器是包含4个状态的状态机：<br>
<img src="https://fire1000.github.io/post-images/1655897874811.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第17章 泛型 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-17-zhang-fan-xing-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-17-zhang-fan-xing-bi-ji/">
        </link>
        <updated>2022-06-22T06:55:36.000Z</updated>
        <content type="html"><![CDATA[<p>泛型(generic)是C# 2.0引入的。<br>
泛型允许我们声明类型参数化(type-parameterized)的代码。<br>
泛型不是类型，是类型的模板。<br>
C#提供5种泛型：类、结构、接口、委托、方法。</p>
<p>泛型声明中的T是占位符，在编译时替换为实际类型，其中T称为类型参数(type parameter)，实际类型称为类型实参(type argument)。</p>
<p>将泛型类型中的占位符替换为实际类型后，得到的类型称为构造类型(constructed type)。</p>
<p>类型参数可以受约束(constrain)，符合约束的类型参数称为未绑定的类型参数(unbounded type parameter)。<br>
泛型中，约束通过where子句给出：</p>
<pre><code>where TypeParam : constraint, constraint, ....
</code></pre>
<p>约束有5种类型：<br>
<img src="https://fire1000.github.io/post-images/1655882211039.png" alt="" loading="lazy"><br>
如果同时存在多种约束，必须按以下形式给出：<br>
<img src="https://fire1000.github.io/post-images/1655882322015.png" alt="" loading="lazy"></p>
<p>泛型方法可以在泛型或非泛型的类型中声明。<br>
泛型方法调用时，编译器可以推断实际类型，因此在调用时，可以省略类型参数和尖括号。<br>
扩展方法支持泛型。</p>
<p>非泛型类型可以实现泛型接口。<br>
一个类型可以重复实现相同的泛型接口，但泛型接口的类型实参必须不存在相同类型的可能性。</p>
<p>泛型可以与非泛型重名。</p>
<p>可变性(variance)分为三种：协变(convariance)、逆变(contravariance)和不变(invariance)。<br>
当泛型委托的类型形参使用out修饰，表示这个类型形参只作为返回值类型，则这个泛型委托支持协变，即支持将类型实参为派生类的委托对象赋值给类型实参为基类的委托对象。<br>
当泛型委托的类型形参使用in修饰，表示这个类型形参只作为形参类型，则这个泛型委托支持逆变，即支持将类型实参为基类的委托对象赋值给类型实参为派生类的委托对象。<br>
与泛型委托相同，泛型接口也通过out和in修饰符支持协变和逆变。<br>
不使用out和in修饰的类型参数称为不变，不支持协变和逆变。</p>
<p>当赋值运算符左操作数为泛型委托，右操作数为函数时，不需要out和in修饰符，只要类型形参满足协变和逆变的条件(协变：只作为返回值类型。逆变：只作为形参类型。)，就支持协变和逆变：<br>
<img src="https://fire1000.github.io/post-images/1655885505456.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第16章 转换 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-16-zhang-zhuan-huan-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-16-zhang-zhuan-huan-bi-ji/">
        </link>
        <updated>2022-06-22T04:39:39.000Z</updated>
        <content type="html"><![CDATA[<p>隐式转换指编译器依据上下文自动进行的转换。<br>
C#中无符号整数类型使用零扩展(zero extension)，有符号整数类型使用符号扩展(sign extension)。<br>
所有类型都可以隐式转换为object类型。<br>
所有值类型都可以隐式转换为System.ValueType类型。</p>
<p>数字类型之间的转换：<br>
<img src="https://fire1000.github.io/post-images/1655873308577.png" alt="" loading="lazy"><br>
数字类型之间的隐式转换：<br>
<img src="https://fire1000.github.io/post-images/1655873440475.png" alt="" loading="lazy"></p>
<p>checked运算符和checked语句可以检查类型转换时是否发生溢出，当溢出时抛出OverflowException异常。C#默认不做溢出检测。<br>
checked和unchecked运算符用于表达式，checked和unchecked语句用于块。<br>
checked检测溢出，unchecked不检测溢出：<br>
<img src="https://fire1000.github.io/post-images/1655873805046.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655873931343.png" alt="" loading="lazy"><br>
checked和unchecked语句之间可以嵌套。</p>
<p>数字类型之间的显式转换：<br>
<img src="https://fire1000.github.io/post-images/1655876435259.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876439453.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876443171.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876447648.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876451648.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876454975.png" alt="" loading="lazy"></p>
<p>引用转换改变对象内存中数据的可见性。<br>
引用类型之间的隐式转换：<br>
<img src="https://fire1000.github.io/post-images/1655876800160.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876805007.png" alt="" loading="lazy"></p>
<p>引用类型之间的显式转换：</p>
<ol>
<li>存在从object到任何引用类型的显式转换。</li>
<li>存在从基类到它的派生类的显式转换。</li>
</ol>
<p>引用类型之间的显式转换不一定都是有效的，无效的引用转换会抛出InvalidCastException异常，但不会导致编译错误。<br>
值为null的引用的显式转换总是有效的。</p>
<p>装箱(boxing)是一种隐式转换。它在堆上创建值类型的副本，然后返回这个副本的引用。<br>
<img src="https://fire1000.github.io/post-images/1655879186162.png" alt="" loading="lazy"><br>
拆箱(unboxing)是一种显式转换。它返回装箱在堆上创建的副本的原始类型的值。尝试将一个值拆箱为非原始类型，抛出InvalidCastException异常。<br>
<img src="https://fire1000.github.io/post-images/1655879463752.png" alt="" loading="lazy"></p>
<p>用户可以通过implicit和explicit关键字和public static修饰符自定义转换。但存在以下约束：</p>
<ol>
<li>只以为类和结定自定义转换</li>
<li>不能重定义标准隐式或显式转换。</li>
<li>对于源类型S和目标类型T：
<ol>
<li>S和T必须是不同类型。</li>
<li>S和T不能有继承关系。</li>
<li>S和T不能是接口或object类型。</li>
<li>转换运算符必须是S或T的成员。</li>
</ol>
</li>
</ol>
<p>一次完整的转换最多三个步骤：<br>
<img src="https://fire1000.github.io/post-images/1655879943707.png" alt="" loading="lazy"></p>
<ul>
<li>自定义转换至多出现一次。</li>
</ul>
<p>is运算符可以检测一次转换是否会成功，会成功返回true，否则返回false。<br>
is运算符只能用于标准引用转换、装箱和拆箱，不能用于自定义转换。</p>
<p>as运算符同样可以检测一次转换是否会成功，成功时返回目标类型的引用，否则返回null。<br>
因为as运算符的目标类型限定为引用类型，所以只用于标准引用转换和装箱，不能用于到值类型的转换，也不能用于自定义转换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第15章 接口 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-15-zhang-jie-kou-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-15-zhang-jie-kou-bi-ji/">
        </link>
        <updated>2022-06-22T03:38:20.000Z</updated>
        <content type="html"><![CDATA[<p>BCL声明了名为IComparable的接口：</p>
<pre><code>public interface IComparable
{
    int CompareTo(object obj);
}
</code></pre>
<ul>
<li>当this小于obj时返回负值，当this等于obj时返回0，当this大于obj时返回正值。</li>
</ul>
<p>Array.Sort()依赖IComparable接口进行排序，如果元素类型没有实现IComparable接口，将抛出异常。</p>
<p>接口不能包含数据成员和静态成员。<br>
接口可以包含非静态的方法、属性、事件、索引器。<br>
接口的函数成员声明的函数体必须为分号。<br>
接口的命名惯例是以大写I起始。<br>
接口支持分部接口声明。<br>
接口支持所有访问修饰符，但它的成员不支持访问修饰符，它的成员是隐式public的。</p>
<p>只有类和结构能实现接口。<br>
实现接口必须实现它的所有成员。<br>
当一个类从基类继承并实现了接口，在它的声明中，基类必须写在最左边。</p>
<pre><code>class Derived: MyBaseClass, IIfc1, IEnumerable, IComparable
{
    ...
}
</code></pre>
<p>接口是引用类型。</p>
<p>使用as运算符，将类对象转换为一个接口对象。</p>
<ol>
<li>如果类实现了这个接口，返回接口引用。</li>
<li>如果类没有实现这个接口，返回null，不抛出异常。</li>
</ol>
<p>当一个类实现的两个接口，有完全相同的成员，即签名与返回值类型都相同。那么两个接口可以共享同一个实现：</p>
<pre><code>interface IIfc1
{
    void PrintOut(sring s);
}
interface IIfc2
{
    void PrintOut(sring s);
}
class MyClass : IIfc1, IIfc2
{
    public void PrintOunt(sring s) // 两个接口的单一实现
    {
        Console.WriteLine(&quot;Calling through: {0}&quot;, s);
    }
}
</code></pre>
<p>实现接口的类可以从它的父类继承实现代码：</p>
<pre><code>interface IIfc1
{
    void PrintOut(sring s);
}
class MyBaseClass
{
    public void PrintOunt(sring s)
    {
        Console.WriteLine(&quot;Calling through: {0}&quot;, s);
    }
}
class Derived : MyBaseClass, IIfc1
{
}
</code></pre>
<p>当一个类实现多个接口时，显式接口成员实现支持每个接口的成员都有各自的实现，即使它们的成员完全相同(签名和返回值类型)。</p>
<pre><code>class MyClass : IIfc1, IIfc2
{
    void IIfc1.PrintOut (sring s)
    { ... }
    void IIfc2..PrintOut (sring s)
    { ... }
}
</code></pre>
<p>显式接口成员实现，只能通过接口引用访问。</p>
<p>接口支持继承接口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第14章 事件 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-14-zhang-shi-jian-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-14-zhang-shi-jian-bi-ji/">
        </link>
        <updated>2022-06-22T02:11:32.000Z</updated>
        <content type="html"><![CDATA[<p>事件是为发布者/订阅者模式(publisher/subscriber pattern)设计的。</p>
<p>不包含事件访问器的事件与自动实现属性类似，封装了一个委托，外部无法直接访问这个委托。执行事件，就是执行它封装的委托。<br>
包含事件访问器的事件与属性类似，add访问器对应+=运算符，remove访问器对应-=运算符。两个访问器都包含一个名为value的隐式值参数，对应+=和-=运算符的右操作数，都不能包含return语句。</p>
<p>事件使用event关键字声明。<br>
事件只能作为类或结构的成员，不能作为本地变量。<br>
不包含事件访问器的事件，如果声明时不显式初始化，则隐式初始化为null，即委托的调用列表为空。</p>
<p>事件不能转换为对应的委托，因此不能出现在赋值运算符的右边。<br>
事件在所属的类或结构外部，只支持作为+=和-=运算符的左操作数。<br>
不包含事件访问器的事件，在所属的类或结构内部，还支持作为=运算符的左操作数。</p>
<p>BCL在System命名空间中声明了EventHandler委托类型，使用这个委托类型声明的事件，称为标准事件。</p>
<pre><code>public delegate void EventHandler(object send, EventArgs e);
</code></pre>
<ul>
<li>sender用于保存触发事件的引用。</li>
<li>e用于传递参数，但EventArgs本身并不能传递参数，因此需要自定义EventArgs的派生类用于传递参数。</li>
</ul>
<pre><code>public delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);
</code></pre>
<ul>
<li>当需要传递参数时，通常使用EventHandler的泛型版本，TEventArgs通常是EventArgs的派生类。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第13章 委托 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-13-zhang-wei-tuo-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-13-zhang-wei-tuo-bi-ji/">
        </link>
        <updated>2022-06-21T12:25:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="委托">委托</h2>
<p>需要先声明委托类型，再使用这个委托类型声明委托对象。<br>
委托类型使用delegate关键字声明。<br>
委托类型不需在类或结构体内声明。</p>
<p>委托是持有0或1或多个方法的对象，执行委托时，委托执行它持有的方法。<br>
委托持有的方法必须与委托类型的函数签名，返回值类型都相同。<br>
委托持有的方法可以是静态方法。</p>
<p>委托对象可以使用new关键字初始化，也可以使用快捷语法：</p>
<pre><code>delVar = new MyDel( myInstObj.MyM1 );
dVar = new MyDel( SClass.OtherM2 );
</code></pre>
<pre><code>delVar = myInstObj.MyM1;
dVar = SClass.OtherM2;
</code></pre>
<p>组合委托(combining delegate)：</p>
<pre><code>MyDel delA = myInstObj.MyM1;
MyDel delB = SClass.OtherM2;

MyDel delC = delA + delB;
</code></pre>
<p>但委托对象在初始化之后就不再改变，改变的只是它持有的方法列表：<br>
<img src="https://fire1000.github.io/post-images/1655815823415.png" alt="" loading="lazy"></p>
<p>委托支持通过+=和-=运算符添加和删除持有的方法。<br>
-=运算符从调用列表末尾开始搜索，删除第一个匹配的方法。如果不存在匹配的方法，没有效果。</p>
<p>执行调用列表为空的委托会抛出异常。<br>
委托可以通过与null比较，判断方法列表是否为空。</p>
<p>当一个方法在调用列表中出现多次，执行委托时会执行多次。</p>
<p>执行委托时传递的参数，会传递给每一个它持有的方法。</p>
<p>执行带返回值的委托，返回调用列表中最后一个方法的返回值。<br>
执行带引用参数的委托，调用时调用列表中下一个方法使用上一个方法调用结束时参数的值。</p>
<h2 id="匿名方法anonymous-method">匿名方法(anonymous method)</h2>
<p>声明委托对象作为初始化表达式，为委托对象赋值时在=和+=运算符的右边，可以使用匿名方法。</p>
<p>匿名方法由delegate关键字、参数列表、方法体组成。<br>
匿名方法不声明返回值类型，返回值类型对应委托的返回值类型。<br>
匿名方法的参数列表必须与对应的委托相匹配。</p>
<ol>
<li>当委托的参数列表不包含out参数，同时匿名方法不使用任何参数时，参数列表可以只保留圆括号或完全省略。</li>
<li>当委托的参数列表包含params参数，匿名方法中params关键字必须省略。</li>
</ol>
<p>在匿名方法中支持访问外部作用域的变量。</p>
<ol>
<li>匿名方法外的这个变量为外部变量(outer variable)</li>
<li>匿名方法内的这个变量为被方法捕获(capured)。</li>
</ol>
<ul>
<li>被捕获的变量的生命周期被延长。</li>
</ul>
<h2 id="lambda表达式">Lambda表达式</h2>
<p>C# 3.0进入Lambda表达式替代C# 2.0引入的匿名方法。<br>
Lambda表达式不使用delegate关键字，使用Lambda运算符=&gt;，读作“goes to”。</p>
<p>Lambda表达式允许在不包含ref或out参数时，省略形参的类型名。当只有一个形参时，并且省略了类型名，可以省略圆括号。当方法体只包含一条return语句时，支持使用return语句中的表达式替代方法体。<br>
<img src="https://fire1000.github.io/post-images/1655819253293.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第12章 数组 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/">
        </link>
        <updated>2022-06-21T10:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>数组的维度称作秩(rank)。<br>
C#有两种多维数组：矩形数组(rectangular array)和交错数组(jagged array)。</p>
<ul>
<li>矩形数组：<code>int x = mayArray2[4, 6, 1]</code></li>
<li>交错数组：<code>jagArray1[2][7][4]</code></li>
</ul>
<p>数组继承自System.Array。System.Array提供了很多属性和方法：<br>
<img src="https://fire1000.github.io/post-images/1655811997129.png" alt="" loading="lazy"></p>
<p>数组声明时，只确定数组的维度。<br>
维度长度不是数组类型的一部分，维度长度在数组实例化时才确定。<br>
与C/C++不同，方括号写在类型后，而不是变量名后。</p>
<p>数组实例化时同样使用new关键字，但不使用圆括号。<br>
数组实例化，元素被初始为元素类型的默认值。<br>
数组支持使用初始化列表初始化，由编译器推断维度长度。</p>
<pre><code>int[] intArr = new int[] {10, 20, 30, 40}; // int[4]
int[, ] intArray2 = new int[, ] { {10, 1}, {20, 2}, {30, 3} };  // int[3, 2]
</code></pre>
<p>如果在声明时初始化数组，C#提供了快捷语法和隐式类型数组(由编译器推断元素类型)：<br>
<img src="https://fire1000.github.io/post-images/1655810851145.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655810955554.png" alt="" loading="lazy"></p>
<p>交错数组初始化时，只能确定顶层维度长度：</p>
<pre><code>int[][] jagArr = new int[3][];
</code></pre>
<p>在CIL中，一维数组特定的性能优化指令，因此使用一维数组的交错数组，有时性能比矩形数组性能更好。</p>
<p>foreach语句中，迭代变量是只读的，可以使用var关键字声明。<br>
foreach语句必须嵌套才能遍历交错数组。</p>
<p>数组的协变：当数组元素为引用类型时，如果某个对象存在从自身类型到数组元素类型的隐式或显式转换，支持将这个元素赋值给数组元素。<br>
<img src="https://fire1000.github.io/post-images/1655811934220.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第11章 枚举 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/">
        </link>
        <updated>2022-06-21T08:02:18.000Z</updated>
        <content type="html"><![CDATA[<p>枚举是值类型。<br>
枚举的成员是命名的整数常量。</p>
<p>枚举的成员的默认类型为int，可以声明为任意整数类型：</p>
<pre><code>enum TrafficLight : ulong
{
    ...
</code></pre>
<p>枚举还常用作标志位。<br>
枚举的HasFlag方法和&amp;运算符，都可以检测一个枚举是否包含某个标志位。</p>
<pre><code>bool useFancyNumbers = ops.HasFlag(CardDeckSetttings.FancyNumbers);
</code></pre>
<ul>
<li>其中CardDeckSetttings是枚举类型，ops是CardDeckSetttings的实例。</li>
<li>HasFlag的实参可以是多个枚举|运算的结果。</li>
</ul>
<p>用作标志位的枚举常使用Flags特性修饰。<br>
Flags特性会重载枚举的ToString()方法，打印枚举对象时，会打印它包含的各个标志位对应的枚举成员名称，而不是输出一个数字。</p>
<p><img src="https://fire1000.github.io/post-images/1655801975966.png" alt="" loading="lazy"><br>
以上代码，当为CardDeckSetttings添加Flags特性，输出变为：</p>
<pre><code>FancyNumbers
FancyNumbers, Animation
</code></pre>
<p>相同类型的枚举成员之间可以使用比较运算符，但不同类型的枚举不行。</p>
<p>枚举对应.NET的Enum类型，提供以下方法：</p>
<ol>
<li>GetName()方法接收一个枚举类型对象和一个整数，返回一个枚举成员名称。</li>
<li>GetNames()方法接收一个枚举类型对象，返回这个枚举的所有成员名称。</li>
</ol>
<p>GetName()和GetNames()方法示例：<br>
<img src="https://fire1000.github.io/post-images/1655802503144.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>