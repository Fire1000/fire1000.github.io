<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fire1000.github.io</id>
    <title>Fly_Fire1000的博客</title>
    <updated>2022-06-22T08:19:47.714Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fire1000.github.io"/>
    <link rel="self" href="https://fire1000.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://fire1000.github.io/images/avatar.png</logo>
    <icon>https://fire1000.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Fly_Fire1000的博客</rights>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第17章 泛型 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-17-zhang-fan-xing-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-17-zhang-fan-xing-bi-ji/">
        </link>
        <updated>2022-06-22T06:55:36.000Z</updated>
        <content type="html"><![CDATA[<p>泛型(generic)允许我们声明类型参数化(type-parameterized)的代码。<br>
泛型不是类型，是类型的模板。<br>
C#提供5种泛型：类、结构、接口、委托、方法。</p>
<p>泛型声明中的T是占位符，在编译时替换为实际类型，其中T称为类型参数(type parameter)，实际类型称为类型实参(type argument)。</p>
<p>将泛型类型中的占位符替换为实际类型后，得到的类型称为构造类型(constructed type)。</p>
<p>类型参数可以受约束(constrain)，符合约束的类型参数称为未绑定的类型参数(unbounded type parameter)。<br>
泛型中，约束通过where子句给出：</p>
<pre><code>where TypeParam : constraint, constraint, ....
</code></pre>
<p>约束有5种类型：<br>
<img src="https://fire1000.github.io/post-images/1655882211039.png" alt="" loading="lazy"><br>
如果同时存在多种约束，必须按以下形式给出：<br>
<img src="https://fire1000.github.io/post-images/1655882322015.png" alt="" loading="lazy"></p>
<p>泛型方法可以在泛型或非泛型的类型中声明。<br>
泛型方法调用时，编译器可以推断实际类型，因此在调用时，可以省略类型参数和尖括号。<br>
扩展方法支持泛型。</p>
<p>非泛型类型可以实现泛型接口。<br>
一个类型可以重复实现相同的泛型接口，但泛型接口的类型实参必须不存在相同类型的可能性。</p>
<p>泛型可以与非泛型重名。</p>
<p>可变性(variance)分为三种：协变(convariance)、逆变(contravariance)和不变(invariance)。<br>
当泛型委托的类型形参使用out修饰，表示这个类型形参只作为返回值类型，则这个泛型委托支持协变，即支持将类型实参为派生类的委托对象赋值给类型实参为基类的委托对象。<br>
当泛型委托的类型形参使用in修饰，表示这个类型形参只作为形参类型，则这个泛型委托支持逆变，即支持将类型实参为基类的委托对象赋值给类型实参为派生类的委托对象。<br>
与泛型委托相同，泛型接口也通过out和in修饰符支持协变和逆变。<br>
不使用out和in修饰的类型参数称为不变，不支持协变和逆变。</p>
<p>当赋值运算符左操作数为泛型委托，右操作数为函数时，不需要out和in修饰符，只要类型形参满足协变和逆变的条件(协变：只作为返回值类型。逆变：只作为形参类型。)，就支持协变和逆变：<br>
<img src="https://fire1000.github.io/post-images/1655885505456.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第16章 转换 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-16-zhang-zhuan-huan-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-16-zhang-zhuan-huan-bi-ji/">
        </link>
        <updated>2022-06-22T04:39:39.000Z</updated>
        <content type="html"><![CDATA[<p>隐式转换指编译器依据上下文自动进行的转换。<br>
C#中无符号整数类型使用零扩展(zero extension)，有符号整数类型使用符号扩展(sign extension)。<br>
所有类型都可以隐式转换为object类型。<br>
所有值类型都可以隐式转换为System.ValueType类型。</p>
<p>数字类型之间的转换：<br>
<img src="https://fire1000.github.io/post-images/1655873308577.png" alt="" loading="lazy"><br>
数字类型之间的隐式转换：<br>
<img src="https://fire1000.github.io/post-images/1655873440475.png" alt="" loading="lazy"></p>
<p>checked运算符和checked语句可以检查类型转换时是否发生溢出，当溢出时抛出OverflowException异常。C#默认不做溢出检测。<br>
checked和unchecked运算符用于表达式，checked和unchecked语句用于块。<br>
checked检测溢出，unchecked不检测溢出：<br>
<img src="https://fire1000.github.io/post-images/1655873805046.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655873931343.png" alt="" loading="lazy"><br>
checked和unchecked语句之间可以嵌套。</p>
<p>数字类型之间的显式转换：<br>
<img src="https://fire1000.github.io/post-images/1655876435259.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876439453.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876443171.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876447648.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876451648.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876454975.png" alt="" loading="lazy"></p>
<p>引用转换改变对象内存中数据的可见性。<br>
引用类型之间的隐式转换：<br>
<img src="https://fire1000.github.io/post-images/1655876800160.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655876805007.png" alt="" loading="lazy"></p>
<p>引用类型之间的显式转换：</p>
<ol>
<li>存在从object到任何引用类型的显式转换。</li>
<li>存在从基类到它的派生类的显式转换。<br>
引用类型之间的显式转换不一定都是有效的，无效的引用转换会抛出InvalidCastException异常，但不会导致编译错误。<br>
值为null的引用的显式转换总是有效的。</li>
</ol>
<p>装箱(boxing)是一种隐式转换。它在堆上创建值类型的副本，然后返回这个副本的引用。<br>
<img src="https://fire1000.github.io/post-images/1655879186162.png" alt="" loading="lazy"><br>
拆箱(unboxing)是一种显式转换。它返回装箱在堆上创建的副本的原始类型的值。尝试将一个值拆箱为非原始类型，抛出InvalidCastException异常。<br>
<img src="https://fire1000.github.io/post-images/1655879463752.png" alt="" loading="lazy"></p>
<p>用户可以通过implicit和explicit关键字和public static修饰符自定义转换。但存在以下约束：</p>
<ol>
<li>只以为类和结定自定义转换</li>
<li>不能重定义标准隐式或显式转换。</li>
<li>对于源类型S和目标类型T：
<ol>
<li>S和T必须是不同类型。</li>
<li>S和T不能有继承关系。</li>
<li>S和T不能是接口或object类型。</li>
<li>转换运算符必须是S或T的成员。</li>
</ol>
</li>
</ol>
<p>一次完整的转换最多三个步骤：<br>
<img src="https://fire1000.github.io/post-images/1655879943707.png" alt="" loading="lazy"></p>
<ul>
<li>自定义转换至多出现一次。</li>
</ul>
<p>is运算符可以检测一次转换是否会成功，会成功返回true，否则返回false。<br>
is运算符只能用于标准引用转换、装箱和拆箱，不能用于自定义转换。</p>
<p>as运算符同样可以检测一次转换是否会成功，成功时返回目标类型的引用，否则返回null。<br>
因为as运算符的目标类型限定为引用类型，所以只用于标准引用转换和装箱，不能用于到值类型的转换，也不能用于自定义转换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第15章 接口 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-15-zhang-jie-kou-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-15-zhang-jie-kou-bi-ji/">
        </link>
        <updated>2022-06-22T03:38:20.000Z</updated>
        <content type="html"><![CDATA[<p>BCL声明了名为IComparable的接口：</p>
<pre><code>public interface IComparable
{
    int CompareTo(object obj);
}
</code></pre>
<ul>
<li>当this小于obj时返回负值，当this等于obj时返回0，当this大于obj时返回正值。</li>
</ul>
<p>Array.Sort()依赖IComparable接口进行排序，如果元素类型没有实现IComparable接口，将抛出异常。</p>
<p>接口不能包含数据成员和静态成员。<br>
接口可以包含非静态的方法、属性、事件、索引器。<br>
接口的函数成员声明的函数体必须为分号。<br>
接口的命名惯例是以大写I起始。<br>
接口支持分部接口声明。<br>
接口支持所有访问修饰符，但它的成员不支持访问修饰符，它的成员是隐式public的。</p>
<p>只有类和结构能实现接口。<br>
实现接口必须实现它的所有成员。<br>
当一个类从基类继承并实现了接口，在它的声明中，基类必须写在最左边。</p>
<pre><code>class Derived: MyBaseClass, IIfc1, IEnumerable, IComparable
{
    ...
}
</code></pre>
<p>接口是引用类型。</p>
<p>使用as运算符，将类对象转换为一个接口对象。</p>
<ol>
<li>如果类实现了这个接口，返回接口引用。</li>
<li>如果类没有实现这个接口，返回null，不抛出异常。</li>
</ol>
<p>当一个类实现的两个接口，有完全相同的成员，即签名与返回值类型都相同。那么两个接口可以共享同一个实现：</p>
<pre><code>interface IIfc1
{
    void PrintOut(sring s);
}
interface IIfc2
{
    void PrintOut(sring s);
}
class MyClass : IIfc1, IIfc2
{
    public void PrintOunt(sring s) // 两个接口的单一实现
    {
        Console.WriteLine(&quot;Calling through: {0}&quot;, s);
    }
}
</code></pre>
<p>实现接口的类可以从它的父类继承实现代码：</p>
<pre><code>interface IIfc1
{
    void PrintOut(sring s);
}
class MyBaseClass
{
    public void PrintOunt(sring s)
    {
        Console.WriteLine(&quot;Calling through: {0}&quot;, s);
    }
}
class Derived : MyBaseClass, IIfc1
{
}
</code></pre>
<p>当一个类实现多个接口时，显式接口成员实现支持每个接口的成员都有各自的实现，即使它们的成员完全相同(签名和返回值类型)。</p>
<pre><code>class MyClass : IIfc1, IIfc2
{
    void IIfc1.PrintOut (sring s)
    { ... }
    void IIfc2..PrintOut (sring s)
    { ... }
}
</code></pre>
<p>显式接口成员实现，只能通过接口引用访问。</p>
<p>接口支持继承接口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第14章 事件 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-14-zhang-shi-jian-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-14-zhang-shi-jian-bi-ji/">
        </link>
        <updated>2022-06-22T02:11:32.000Z</updated>
        <content type="html"><![CDATA[<p>事件是为发布者/订阅者模式(publisher/subscriber pattern)设计的。</p>
<p>不包含事件访问器的事件与自动实现属性类似，封装了一个委托，外部无法直接访问这个委托。执行事件，就是执行它封装的委托。<br>
包含事件访问器的事件与属性类似，add访问器对应+=运算符，remove访问器对应-=运算符。两个访问器都包含一个名为value的隐式值参数，对应+=和-=运算符的右操作数，都不能包含return语句。</p>
<p>事件使用event关键字声明。<br>
事件只能作为类或结构的成员，不能作为本地变量。<br>
不包含事件访问器的事件，如果声明时不显式初始化，则隐式初始化为null，即委托的调用列表为空。</p>
<p>事件不能转换为对应的委托，因此不能出现在赋值运算符的右边。<br>
事件在所属的类或结构外部，只支持作为+=和-=运算符的左操作数。<br>
不包含事件访问器的事件，在所属的类或结构内部，还支持作为=运算符的左操作数。</p>
<p>BCL在System命名空间中声明了EventHandler委托类型，使用这个委托类型声明的事件，称为标准事件。</p>
<pre><code>public delegate void EventHandler(object send, EventArgs e);
</code></pre>
<ul>
<li>sender用于保存触发事件的引用。</li>
<li>e用于传递参数，但EventArgs本身并不能传递参数，因此需要自定义EventArgs的派生类用于传递参数。</li>
</ul>
<pre><code>public delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);
</code></pre>
<ul>
<li>当需要传递参数时，通常使用EventHandler的泛型版本，TEventArgs通常是EventArgs的派生类。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第13章 委托 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-13-zhang-wei-tuo-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-13-zhang-wei-tuo-bi-ji/">
        </link>
        <updated>2022-06-21T12:25:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="委托">委托</h2>
<p>需要先声明委托类型，再使用这个委托类型声明委托对象。<br>
委托类型使用delegate关键字声明。<br>
委托类型不需在类或结构体内声明。</p>
<p>委托是持有0或1或多个方法的对象，执行委托时，委托执行它持有的方法。<br>
委托持有的方法必须与委托类型的函数签名，返回值类型都相同。<br>
委托持有的方法可以是静态方法。</p>
<p>委托对象可以使用new关键字初始化，也可以使用快捷语法：</p>
<pre><code>delVar = new MyDel( myInstObj.MyM1 );
dVar = new MyDel( SClass.OtherM2 );
</code></pre>
<pre><code>delVar = myInstObj.MyM1;
dVar = SClass.OtherM2;
</code></pre>
<p>组合委托(combining delegate)：</p>
<pre><code>MyDel delA = myInstObj.MyM1;
MyDel delB = SClass.OtherM2;

MyDel delC = delA + delB;
</code></pre>
<p>但委托对象在初始化之后就不再改变，改变的只是它持有的方法列表：<br>
<img src="https://fire1000.github.io/post-images/1655815823415.png" alt="" loading="lazy"></p>
<p>委托支持通过+=和-=运算符添加和删除持有的方法。<br>
-=运算符从调用列表末尾开始搜索，删除第一个匹配的方法。如果不存在匹配的方法，没有效果。</p>
<p>执行调用列表为空的委托会抛出异常。<br>
委托可以通过与null比较，判断方法列表是否为空。</p>
<p>当一个方法在调用列表中出现多次，执行委托时会执行多次。</p>
<p>执行委托时传递的参数，会传递给每一个它持有的方法。</p>
<p>执行带返回值的委托，返回调用列表中最后一个方法的返回值。<br>
执行带引用参数的委托，调用时调用列表中下一个方法使用上一个方法调用结束时参数的值。</p>
<h2 id="匿名方法anonymous-method">匿名方法(anonymous method)</h2>
<p>声明委托对象作为初始化表达式，为委托对象赋值时在=和+=运算符的右边，可以使用匿名方法。</p>
<p>匿名方法由delegate关键字、参数列表、方法体组成。<br>
匿名方法不声明返回值类型，返回值类型对应委托的返回值类型。<br>
匿名方法的参数列表必须与对应的委托相匹配。</p>
<ol>
<li>当委托的参数列表不包含out参数，同时匿名方法不使用任何参数时，参数列表可以只保留圆括号或完全省略。</li>
<li>当委托的参数列表包含params参数，匿名方法中params关键字必须省略。</li>
</ol>
<p>在匿名方法中支持访问外部作用域的变量。</p>
<ol>
<li>匿名方法外的这个变量为外部变量(outer variable)</li>
<li>匿名方法内的这个变量为被方法捕获(capured)。</li>
</ol>
<ul>
<li>
<p>被捕获的变量的生命周期被延长。</p>
<h2 id="lambda表达式">Lambda表达式</h2>
</li>
</ul>
<p>C# 3.0进入Lambda表达式替代C# 2.0引入的匿名方法。<br>
Lambda表达式不使用delegate关键字，使用Lambda运算符=&gt;，读作“goes to”。</p>
<p>Lambda表达式允许在不包含ref或out参数时，省略形参的类型名。当只有一个形参时，并且省略了类型名，可以省略圆括号。当方法体只包含一条return语句时，支持使用return语句中的表达式替代方法体。<br>
<img src="https://fire1000.github.io/post-images/1655819253293.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第12章 数组 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-12-zhang-shu-zu-bi-ji/">
        </link>
        <updated>2022-06-21T10:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>数组的维度称作秩(rank)。<br>
C#有两种多维数组：矩形数组(rectangular array)和交错数组(jagged array)。</p>
<ul>
<li>矩形数组：<code>int x = mayArray2[4, 6, 1]</code></li>
<li>交错数组：<code>jagArray1[2][7][4]</code></li>
</ul>
<p>数组继承自System.Array。System.Array提供了很多属性和方法：<br>
<img src="https://fire1000.github.io/post-images/1655811997129.png" alt="" loading="lazy"></p>
<p>数组声明时，只确定数组的维度。<br>
维度长度不是数组类型的一部分，维度长度在数组实例化时才确定。<br>
与C/C++不同，方括号写在类型后，而不是变量名后。</p>
<p>数组实例化时同样使用new关键字，但不使用圆括号。<br>
数组实例化，元素被初始为元素类型的默认值。<br>
数组支持使用初始化列表初始化，由编译器推断维度长度。</p>
<pre><code>int[] intArr = new int[] {10, 20, 30, 40}; // int[4]
int[, ] intArray2 = new int[, ] { {10, 1}, {20, 2}, {30, 3} };  // int[3, 2]
</code></pre>
<p>如果在声明时初始化数组，C#提供了快捷语法和隐式类型数组(由编译器推断元素类型)：<br>
<img src="https://fire1000.github.io/post-images/1655810851145.png" alt="" loading="lazy"><br>
<img src="https://fire1000.github.io/post-images/1655810955554.png" alt="" loading="lazy"></p>
<p>交错数组初始化时，只能确定顶层维度长度：</p>
<pre><code>int[][] jagArr = new int[3][];
</code></pre>
<p>在CIL中，一维数组特定的性能优化指令，因此使用一维数组的交错数组，有时性能比矩形数组性能更好。</p>
<p>foreach语句中，迭代变量是只读的，可以使用var关键字声明。<br>
foreach语句必须嵌套才能遍历交错数组。</p>
<p>数组的协变：当数组元素为引用类型时，如果某个对象存在从自身类型到数组元素类型的隐式或显式转换，支持将这个元素赋值给数组元素。<br>
<img src="https://fire1000.github.io/post-images/1655811934220.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第11章 枚举 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-11-zhang-mei-ju-bi-ji/">
        </link>
        <updated>2022-06-21T08:02:18.000Z</updated>
        <content type="html"><![CDATA[<p>枚举是值类型。<br>
枚举的成员是命名的整数常量。</p>
<p>枚举的成员的默认类型为int，可以声明为任意整数类型：</p>
<pre><code>enum TrafficLight : ulong
{
    ...
</code></pre>
<p>枚举还常用作标志位。<br>
枚举的HasFlag方法和&amp;运算符，都可以检测一个枚举是否包含某个标志位。</p>
<pre><code>bool useFancyNumbers = ops.HasFlag(CardDeckSetttings.FancyNumbers);
</code></pre>
<ul>
<li>其中CardDeckSetttings是枚举类型，ops是CardDeckSetttings的实例。</li>
<li>HasFlag的实参可以是多个枚举|运算的结果。</li>
</ul>
<p>用作标志位的枚举常使用Flags特性修饰。<br>
Flags特性会重载枚举的ToString()方法，打印枚举对象时，会打印它包含的各个标志位对应的枚举成员名称，而不是输出一个数字。</p>
<p><img src="https://fire1000.github.io/post-images/1655801975966.png" alt="" loading="lazy"><br>
以上代码，当为CardDeckSetttings添加Flags特性，输出变为：</p>
<pre><code>FancyNumbers
FancyNumbers, Animation
</code></pre>
<p>相同类型的枚举成员之间可以使用比较运算符，但不同类型的枚举不行。</p>
<p>枚举对应.NET的Enum类型，提供以下方法：</p>
<ol>
<li>GetName()方法接收一个枚举类型对象和一个整数，返回一个枚举成员名称。</li>
<li>GetNames()方法接收一个枚举类型对象，返回这个枚举的所有成员名称。</li>
</ol>
<p>GetName()和GetNames()方法示例：<br>
<img src="https://fire1000.github.io/post-images/1655802503144.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第10章 结构 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-10-zhang-jie-gou-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-10-zhang-jie-gou-bi-ji/">
        </link>
        <updated>2022-06-21T07:27:42.000Z</updated>
        <content type="html"><![CDATA[<p>与类不同，结构是值类型。</p>
<p>结构不允许有析构函数。<br>
C#为每个结构隐式提供一个无参实例构造函数，它将每个成员设置为类型的默认值。<br>
无法为结构显式声明无参实例构造函数。</p>
<p>结构同样可以使用new运算符创建实例，但这与是否从堆中分配内存无关。<br>
当结构不使用new运算符创建实例时，数据成员显式赋值后才可以访问，函数成员在所有数据成员显式赋值之后才可以调用。<br>
<img src="https://fire1000.github.io/post-images/1655796922134.png" alt="" loading="lazy"></p>
<p>在结构中字段初始化语句是不允许的。</p>
<p>结构是隐式密封的，不能被继承。因此，不能使用protected、internal、abstract、virtual修饰结构的成员。<br>
结构派生自System.ValueType，System.ValueType派生自object。因此，可以使用new、override修饰符，隐藏和覆写System.ValueType的成员。</p>
<p>预定义简单类型(int等)在.NET中都由结构实现。</p>
<p>结构可以实现接口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第9章 语句 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-9-zhang-yu-ju-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-9-zhang-yu-ju-bi-ji/">
        </link>
        <updated>2022-06-21T02:37:24.000Z</updated>
        <content type="html"><![CDATA[<p>与C/C++不同，条件语句和循环语句中测试表达式必须返回bool值，不能是数字。</p>
<p>跳转语句包括return、break、continue、goto、throw。</p>
<p>与C/C++不同，switch语句的每个分支(case或default)通常都必须使用跳转语句结尾，仅当不包含任何语句时例外。<br>
<img src="https://fire1000.github.io/post-images/1655792065007.png" alt="" loading="lazy"></p>
<p>break语句仅能在switch、while、do、for、foreach语句中使用，跳出最内层的封装语句(innermost enclosing statement)。<br>
continue语句仅能在while、do、for、foreach语句中使用，跳转到最内层的封装语句的起始处。</p>
<p>标签语句定义一个标签，标签的作用域为作处的块内。</p>
<pre><code>Indentifier: Statement
</code></pre>
<p>goto语句可以跳转到一个标签。</p>
<pre><code>goto Identifier;
</code></pre>
<p>goto语句还可以跳转到switch语句中的case和default标签。</p>
<pre><code>goto cae ConstantExpression;
goto default;
</code></pre>
<p>using语句是语法糖，用于确保在资源使用完毕之后，调用Dispose()方法。<br>
资源指实际了System.IDisposable接口的类型。<br>
System.IDisposable接口只有一个方法，就是Dispose()。<br>
using语句有两种形式：<br>
<img src="https://fire1000.github.io/post-images/1655795356426.png" alt="" loading="lazy"></p>
<ul>
<li>using语句可以用于多个同类型的资源，以逗号分隔。<br>
<img src="https://fire1000.github.io/post-images/1655795401127.png" alt="" loading="lazy"></li>
<li>第二种形式资源使用之前可能已经被释放，不推荐。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Illustrated C# 2012, 4th Edition》Daniel M. Solis 第8章 表达式和运算符 笔记]]></title>
        <id>https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-8-zhang-biao-da-shi-he-yun-suan-fu-bi-ji/</id>
        <link href="https://fire1000.github.io/post/lesslessillustrated-c-2012-4th-editiongreatergreater-daniel-m-solis-di-8-zhang-biao-da-shi-he-yun-suan-fu-bi-ji/">
        </link>
        <updated>2022-06-18T03:35:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="表达式">表达式</h2>
<p>表达式除了返回一个值以外的功能，称为副作用，比如分配内存，又比如赋值表达式设置左边操作数的值是它的副作用。</p>
<h2 id="字面值">字面值</h2>
<p>整数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655523693428.png" alt="" loading="lazy"><br>
整数字面值的类型是，后辍对应的类型中，能容纳这个值的最小的类型。</p>
<p>浮点数字面值后辍：<br>
<img src="https://fire1000.github.io/post-images/1655633313375.png" alt="" loading="lazy"></p>
<p>字符字面值有四种：<br>
<img src="https://fire1000.github.io/post-images/1655634956854.png" alt="" loading="lazy"><br>
\x和\u都后跟4位十六进制数。</p>
<ul>
<li>经测试\x和\u完全没有区别，编码为UCS-2 BE。'\x4E2D'和'\u4E2D'都输出<code>中</code>，测试环境为Intel CPU。</li>
</ul>
<p>转义序列：<br>
<img src="https://fire1000.github.io/post-images/1655635304774.png" alt="" loading="lazy"></p>
<p>@前辍的字符串是逐字字符串：</p>
<ol>
<li>转义序列不被求值。</li>
<li>支持换行符。</li>
<li>连续的两个引号解释为一个引号。</li>
</ol>
<p>除了rst3和vst3，以下逐字字符串与普通字符串有完全相同的输出：<br>
<img src="https://fire1000.github.io/post-images/1655710704418.png" alt="" loading="lazy"></p>
<p>C#编译器使得相同的字符串字面值占堆中同一块内存。</p>
<h2 id="运算符">运算符</h2>
<p>运算符优先级：<br>
<img src="https://fire1000.github.io/post-images/1655710924275.png" alt="" loading="lazy"></p>
<p>运算符结合性：<br>
<img src="https://fire1000.github.io/post-images/1655710956571.png" alt="" loading="lazy"></p>
<p>C#求余运算符%支持浮点数。</p>
<p>与C/C++不同，C#中数字不具有布尔意义。<br>
相等运算符比较引用类型时，除了比较string和委托使用深比较，其他都使用浅比较。</p>
<ul>
<li>浅比较只比较引用的地址。</li>
<li>深比较只比较引用指向的内存中的数据。</li>
</ul>
<p>C#中&amp;&amp;和||是短路运算符，当左边的表达式足以确定返回值时，右边的表达式不求值。</p>
<p>C#中右移运算符，对于有符号整数符号位填充，对于无符号整数0填充。</p>
<p>if...else语句执行两个行为其中一个，条件运算符返回两个值其中一个。</p>
<h2 id="自定义类型转换">自定义类型转换</h2>
<p>C#支持自定义类型转换，隐式转换由编译器依据上下文自行调用，显式转换在使用强制转换运算符时调用。<br>
自定义类型转换的语法：<br>
<img src="https://fire1000.github.io/post-images/1655720026416.png" alt="" loading="lazy"></p>
<ul>
<li>显式转换使用explicit关键字，隐式转换使用implicit关键字。</li>
<li>无论是显式转换还是隐式转换，public和static修饰符都是必需的。</li>
<li>源类型与目标类型不能相同。</li>
</ul>
<h2 id="运算符重载">运算符重载</h2>
<p>运算符重载的参数至少要有一个是所属的类或结构类型，语法如下：<br>
<img src="https://fire1000.github.io/post-images/1655720993031.png" alt="" loading="lazy"></p>
<ul>
<li>public和static修饰符是必需的。</li>
</ul>
<p>可重载的运算符：<br>
<img src="https://fire1000.github.io/post-images/1655721044770.png" alt="" loading="lazy"></p>
<ul>
<li>强制转换计入自定义类型转换，不计入运算符重载。</li>
</ul>
<h2 id="typeof运算符">typeof运算符</h2>
<p>typeof运算符与实例的GetType()方法相同，返回System.Type对象，直接打印这个对象会输出类型名。通过GetFields()和GetMethods()方法，还可以获得字段成员和方法成员信息：<br>
<img src="https://fire1000.github.io/post-images/1655722585884.png" alt="" loading="lazy"></p>
<ul>
<li>FieldInfo和MethodInfo在System.Reflection命名空间中定义。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fire1000.github.io/post-images/1655722663460.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>